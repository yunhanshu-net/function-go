# Go Validator 条件验证标签详细文档

## 🎯 什么是条件验证？

条件验证是指**根据其他字段的值来决定当前字段是否必填或必不填**的验证方式。它让表单验证更加智能和灵活。

## 🔍 条件验证标签详解

### 1. required_if - 条件必填

**语法**：`required_if=字段名 值`

**含义**：当指定字段等于指定值时，当前字段必填

```go
type OrderForm struct {
    OrderType string `json:"order_type" validate:"required,oneof=在线 线下"`
    
    // 当 order_type 等于 "在线" 时，address 必填
    // required_if=order_type 在线: 当order_type字段等于"在线"时，此字段必填
    Address string `json:"address" validate:"required_if=order_type 在线"`
    
    // 当 order_type 等于 "线下" 时，store_id 必填
    // required_if=order_type 线下: 当order_type字段等于"线下"时，此字段必填
    StoreId int `json:"store_id" validate:"required_if=order_type 线下"`
}
```

**验证逻辑表**：
| order_type 值 | address 验证 | store_id 验证 |
|-------------|-------------|--------------|
| "在线" | ✅ 必填 | ❌ 不必填 |
| "线下" | ❌ 不必填 | ✅ 必填 |
| 其他值 | ❌ 不必填 | ❌ 不必填 |

---

### 2. required_unless - 反向条件必填

**语法**：`required_unless=字段名 值`

**含义**：当指定字段不等于指定值时，当前字段必填

```go
type UserForm struct {
    UserType string `json:"user_type" validate:"required,oneof=管理员 普通用户 游客"`
    
    // 当 user_type 不等于 "管理员" 时，department 必填
    // required_unless=user_type 管理员: 当user_type字段不等于"管理员"时，此字段必填
    Department string `json:"department" validate:"required_unless=user_type 管理员"`
    
    // 当 user_type 不等于 "游客" 时，email 必填
    // required_unless=user_type 游客: 当user_type字段不等于"游客"时，此字段必填
    Email string `json:"email" validate:"required_unless=user_type 游客,email"`
}
```

**验证逻辑表**：
| user_type 值 | department 验证 | email 验证 |
|-------------|---------------|-----------|
| "管理员" | ❌ 不必填 | ✅ 必填 |
| "普通用户" | ✅ 必填 | ✅ 必填 |
| "游客" | ✅ 必填 | ❌ 不必填 |

---

### 3. excluded_if - 条件必不填

**语法**：`excluded_if=字段名 值`

**含义**：当指定字段等于指定值时，当前字段必须为空

```go
type FileShareForm struct {
    DownloadLimit string `json:"download_limit" validate:"required,oneof=限制次数 不限次数"`
    
    // 当 download_limit 等于 "不限次数" 时，max_downloads 必不填
    // excluded_if=download_limit 不限次数: 当download_limit字段等于"不限次数"时，此字段必须为空
    MaxDownloads int `json:"max_downloads" validate:"excluded_if=download_limit 不限次数,min=1,max=10000"`
    
    // 当 download_limit 等于 "限制次数" 时，unlimited_flag 必不填
    // excluded_if=download_limit 限制次数: 当download_limit字段等于"限制次数"时，此字段必须为空
    UnlimitedFlag bool `json:"unlimited_flag" validate:"excluded_if=download_limit 限制次数"`
}
```

**验证逻辑表**：
| download_limit 值 | max_downloads 验证 | unlimited_flag 验证 |
|-----------------|------------------|-------------------|
| "限制次数" | ✅ 可以填写 | ❌ 必不填 |
| "不限次数" | ❌ 必不填 | ✅ 可以填写 |
| 其他值 | ✅ 可以填写 | ✅ 可以填写 |

---

### 4. excluded_unless - 反向条件必不填

**语法**：`excluded_unless=字段名 值`

**含义**：当指定字段不等于指定值时，当前字段必须为空

```go
type AdminForm struct {
    UserType string `json:"user_type" validate:"required,oneof=管理员 普通用户 游客"`
    
    // 当 user_type 不等于 "管理员" 时，admin_level 必不填
    // excluded_unless=user_type 管理员: 当user_type字段不等于"管理员"时，此字段必须为空
    AdminLevel int `json:"admin_level" validate:"excluded_unless=user_type 管理员,min=1,max=5"`
    
    // 当 user_type 不等于 "游客" 时，guest_info 必不填
    // excluded_unless=user_type 游客: 当user_type字段不等于"游客"时，此字段必须为空
    GuestInfo string `json:"guest_info" validate:"excluded_unless=user_type 游客"`
}
```

**验证逻辑表**：
| user_type 值 | admin_level 验证 | guest_info 验证 |
|-------------|----------------|---------------|
| "管理员" | ✅ 可以填写 | ❌ 必不填 |
| "普通用户" | ❌ 必不填 | ❌ 必不填 |
| "游客" | ❌ 必不填 | ✅ 可以填写 |

---

## 🔧 组合使用示例

```go
type ComplexForm struct {
    // 基础字段
    FormType string `json:"form_type" validate:"required,oneof=个人 企业 政府"`
    UserType string `json:"user_type" validate:"required,oneof=管理员 普通用户 游客"`
    
    // 条件必填字段
    // 当 form_type 等于 "企业" 时，company_name 必填
    // required_if=form_type 企业: 当form_type字段等于"企业"时，此字段必填
    CompanyName string `json:"company_name" validate:"required_if=form_type 企业"`
    
    // 当 user_type 不等于 "游客" 时，email 必填
    // required_unless=user_type 游客: 当user_type字段不等于"游客"时，此字段必填
    Email string `json:"email" validate:"required_unless=user_type 游客,email"`
    
    // 条件必不填字段
    // 当 form_type 等于 "个人" 时，company_info 必不填
    // excluded_if=form_type 个人: 当form_type字段等于"个人"时，此字段必须为空
    CompanyInfo string `json:"company_info" validate:"excluded_if=form_type 个人"`
    
    // 当 user_type 不等于 "管理员" 时，admin_level 必不填
    // excluded_unless=user_type 管理员: 当user_type字段不等于"管理员"时，此字段必须为空
    AdminLevel int `json:"admin_level" validate:"excluded_unless=user_type 管理员,min=1,max=5"`
    
    // 多重条件验证
    // 当 form_type 等于 "企业" 且 user_type 等于 "管理员" 时，license_number 必填
    // required_if=form_type 企业: 当form_type字段等于"企业"时，此字段必填
    // required_if=user_type 管理员: 当user_type字段等于"管理员"时，此字段必填
    LicenseNumber string `json:"license_number" validate:"required_if=form_type 企业,required_if=user_type 管理员"`
}
```

## ⚠️ 重要注意事项

### 1. 字段名使用 JSON 标签
```go
type User struct {
    UserType string `json:"user_type"`  // 使用 user_type，不是 UserType
}

// 正确
AdminLevel int `validate:"required_if=user_type 管理员"`

// 错误
AdminLevel int `validate:"required_if=UserType 管理员"`
```

### 2. 值匹配完全一致
```go
// 正确：值完全匹配
Status string `validate:"required_if=user_type 管理员"`

// 错误：值不匹配
Status string `validate:"required_if=user_type 管理员用户"`  // 多了"用户"
```

### 3. 空格敏感
```go
// 正确：字段名和值之间用空格分隔
validate:"required_if=user_type 管理员"

// 错误：多余空格
validate:"required_if=user_type  管理员"  // 两个空格
```

### 4. 多个条件验证
```go
// 多个条件用逗号分隔
AdminLevel int `validate:"required_if=user_type 管理员,min=1,max=5,excluded_if=user_type 游客"`
```

## 🎯 实际应用场景

### 场景1：文件分享系统
```go
type FileShareForm struct {
    FileType string `json:"file_type" validate:"required,oneof=临时文件 永久文件"`
    DownloadLimit string `json:"download_limit" validate:"required,oneof=限制次数 不限次数"`
    
    // 永久文件不能设置过期时间
    // excluded_if=file_type 永久文件: 当file_type字段等于"永久文件"时，此字段必须为空
    ExpiresInDays int `json:"expires_in_days" validate:"excluded_if=file_type 永久文件,min=1,max=365"`
    
    // 选择"限制次数"时必须设置最大下载次数
    // required_if=download_limit 限制次数: 当download_limit字段等于"限制次数"时，此字段必填
    MaxDownloads int `json:"max_downloads" validate:"required_if=download_limit 限制次数,min=1,max=10000"`
    
    // 选择"不限次数"时不能设置最大下载次数
    // excluded_if=download_limit 不限次数: 当download_limit字段等于"不限次数"时，此字段必须为空
    MaxDownloads2 int `json:"max_downloads2" validate:"excluded_if=download_limit 不限次数"`
}
```

### 场景2：用户注册系统
```go
type UserRegisterForm struct {
    UserType string `json:"user_type" validate:"required,oneof=个人 企业 政府"`
    
    // 企业用户必须填写公司名称
    // required_if=user_type 企业: 当user_type字段等于"企业"时，此字段必填
    CompanyName string `json:"company_name" validate:"required_if=user_type 企业"`
    
    // 非个人用户必须填写联系人
    // required_unless=user_type 个人: 当user_type字段不等于"个人"时，此字段必填
    ContactPerson string `json:"contact_person" validate:"required_unless=user_type 个人"`
    
    // 个人用户不能填写公司信息
    // excluded_if=user_type 个人: 当user_type字段等于"个人"时，此字段必须为空
    CompanyInfo string `json:"company_info" validate:"excluded_if=user_type 个人"`
    
    // 只有企业用户才能填写营业执照号
    // excluded_unless=user_type 企业: 当user_type字段不等于"企业"时，此字段必须为空
    LicenseNumber string `json:"license_number" validate:"excluded_unless=user_type 企业"`
}
```

### 场景3：订单系统
```go
type OrderForm struct {
    OrderType string `json:"order_type" validate:"required,oneof=在线 线下 自提"`
    PaymentMethod string `json:"payment_method" validate:"required,oneof=在线支付 货到付款 自提付款"`
    
    // 在线订单必须填写收货地址
    // required_if=order_type 在线: 当order_type字段等于"在线"时，此字段必填
    Address string `json:"address" validate:"required_if=order_type 在线"`
    
    // 线下订单必须选择门店
    // required_if=order_type 线下: 当order_type字段等于"线下"时，此字段必填
    StoreId int `json:"store_id" validate:"required_if=order_type 线下"`
    
    // 自提订单必须填写自提点
    // required_if=order_type 自提: 当order_type字段等于"自提"时，此字段必填
    PickupPoint string `json:"pickup_point" validate:"required_if=order_type 自提"`
    
    // 货到付款时不能选择在线支付
    // excluded_if=payment_method 货到付款: 当payment_method字段等于"货到付款"时，此字段必须为空
    OnlinePayment bool `json:"online_payment" validate:"excluded_if=payment_method 货到付款"`
}
```

## 🚀 最佳实践

1. **合理使用**：不要过度使用条件验证，保持逻辑清晰
2. **测试覆盖**：为各种条件组合编写测试用例
3. **错误提示**：验证失败时提供清晰的错误信息
4. **文档说明**：在代码中添加注释说明验证逻辑
5. **用户友好**：前端根据条件动态显示/隐藏字段

## 📝 总结

条件验证标签让表单验证变得非常强大和灵活：

- **required_if**：等于时必填
- **required_unless**：不等于时必填  
- **excluded_if**：等于时必不填
- **excluded_unless**：不等于时必不填

通过合理使用这些标签，可以创建智能的表单验证逻辑，提升用户体验和数据的准确性。
