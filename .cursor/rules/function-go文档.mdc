# function-go - AI原生全栈开发框架

> **专为大模型设计的Go全栈开发框架**
> AI原生结构体标签系统 | 一个文件 = 一个完整Web应用 | 大模型生成代码直接编译部署 | 框架内部有运行入口，专注业务函数

## 🏷️ 标签系统 - 大模型代码生成核心

### 设计理念

function-go通过结构体标签实现**声明式配置**，让大模型能够：

- **零样板代码**：一个结构体 = 完整Web应用
- **AI友好**：标签即配置，大模型直接理解
- **业务导向**：专注业务逻辑，框架处理技术细节

### 💡 大模型使用指南

**记住：标签就是配置，配置就是功能！**

| 标签 | 作用         | 大模型使用场景   |
| ------ | -------------- | ------------------ |
| `runner:"name:字段名"`     | 前端显示名称 | 所有字段都需要   |
| `widget:"type:组件类型"`     | UI组件选择   | 根据数据类型选择 |
| `validate:"required"`     | 数据验证     | 必填字段必须加   |
| `search:"like"`     | 搜索功能     | 需要搜索的字段   |

### 快速上手模板

```go
// 大模型代码生成模板
type YourModel struct {
    ID        int    `json:"id" gorm:"primaryKey" runner:"name:ID" permission:"read"` //这个字段只读
    Name      string `json:"name" runner:"name:名称" widget:"type:input" search:"like" validate:"required"`
    Status    string `json:"status" runner:"name:状态" widget:"type:select;options:启用,禁用" search:"in"`
    CreatedAt int64  `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" permission:"read"`
}
```

#### 2. **UI渲染**

- **widget标签**：选择最合适的UI组件进行渲染
- **data标签**：自动设置默认值、示例值、动态值，格式化的值，
- **runner标签**：自动生成中文标签、单位、显示名称

#### 3. **数据验证引擎**

- **validate标签**：自动生成前端和后端验证规则
- **search标签**：自动生成搜索和过滤功能
- **permission标签**：自动控制字段在不同场景的显示权限

#### 4. **数据库操作自动化**

- **gorm标签**：自动生成数据库表结构
- **CreateTables**：服务启动时自动建表
- **AutoCrudTable**：自动生成增删改查操作

#### 5. **回调函数集成**

- **OnInputFuzzy**：自动集成模糊搜索和聚合计算
- **OnInputValidate**：自动集成实时字段验证
- **OnTableAddRows**：table函数新增记录回调
- **OnTableUpdateRows** table函数更新记录回调
- **OnTableDeleteRows** table函数删除记录回调

### 🔄 标签系统的工作流程

```
结构体定义 → 标签解析 → 代码生成 → 运行时执行
     ↓           ↓         ↓         ↓
  业务模型   配置信息   前端界面   完整应用
  数据库表   验证规则   API接口   业务逻辑
```

### 🌟 标签系统的优势

| 传统开发方式     | function-go标签方式 |
| ------------------ | --------------------- |
| 手动编写CRUD代码 | 自动生成CRUD代码    |
| 手动编写验证逻辑 | 标签声明验证规则    |
| 手动设计UI界面   | 自动渲染UI界面      |
| 手动管理数据库   | 自动管理数据库      |
| 代码量大、易出错 | 代码简洁、零错误    |

通过标签系统，开发者只需要关注**业务逻辑**，框架自动处理所有**技术细节**，真正实现了"一个文件 = 一个完整Web应用"的愿景。

### 标签顺序建议

```
json → gorm → runner → widget → data → search → permission → validate
```

### 核心标签说明

#### runner标签 - 业务逻辑配置

| 属性     | 格式 | 示例 | 说明                         |
| ---------- | ------ | ------ | ------------------------------ |
| 字段名称 | `name:显示名称`     | `runner:"name:用户名"`     | 设置字段在前端的显示名称     |
| 字段单位 | `desc:字段介绍`     | `runner:"name:年龄;desc:年龄0-100"`     | 设置字段的详细介绍（非必要） |

#### widget标签 - UI组件配置

| 属性     | 格式 | 示例 | 说明           |
| ---------- | ------ | ------ | ---------------- |
| 组件类型 | `type:组件类型`     | `widget:"type:input"`     | 设置UI组件类型 |

#### data标签 - 数据和值配置

| 功能       | 格式 | 示例 | 说明               |
| ------------ | ------ | ------ | -------------------- |
| 默认值     | `default_value:值`     | `data:"default_value:默认值"`     | 设置字段默认值     |
| 示例值     | `example:示例值`     | `data:"example:示例文本"`     | 设置示例值         |
| 动态默认值 | `default_value:$变量`     | `data:"default_value:$now"`     | 使用变量作为默认值 |
| 格式化     | `format:格式化类型`     | `format:markdown`     | `设置格式化类型，csv或者markdown`                   |

#### validate标签 - 验证规则

| 规则     | 格式 | 示例 | 说明         |
| ---------- | ------ | ------ | -------------- |
| 必填验证 | `required`     | `validate:"required"`     | 字段必填     |
| 长度验证 | `min=值,max=值`     | `validate:"min=2,max=50"`     | 长度范围验证 |
| 数值验证 | `min=值,max=值`     | `validate:"min=1,max=120"`     | 数值范围验证 |
| 枚举验证 | `oneof=值1 值2`     | `validate:"oneof=男 女"`     | 枚举值验证   |

#### search标签 - 搜索配置（仅table函数）

| 搜索类型 | 格式 | 示例 | 说明                       |
| ---------- | ------ | ------ | ---------------------------- |
| 模糊搜索 | `like`     | `search:"like"`     | 启用模糊搜索               |
| 精确搜索 | `eq`     | `search:"eq"`     | 启用精确搜索               |
| 区间搜索 | `gte,lte`     | `search:"gte,lte"`     | 启用大于等于、小于等于搜索 |
| 多选搜索 | `in`     | `search:"in"`     | 启用多选搜索               |

#### permission标签 - 权限控制（仅table函数）

| 权限类型 | 格式 | 示例   | 说明                   |
| ---------- | ------ | -------- | ------------------------ |
| 仅可读   | `read`     | `permission:"read"`       | 仅列表显示，不能编辑   |
| 仅可创建 | `create`     | `permission:"create"`       | 仅新增显示，列表不显示 |
| 仅可更新 | `update`     | `permission:"update"`       | 仅编辑显示，列表不显示 |
| 全权限   | 不写 | 无标签 | 列表、新增、编辑都显示 |

## 🧩 组件系统

### 基础输入组件

#### input组件 - 文本输入

| 类型     | 配置 | 示例 | 说明           |
| ---------- | ------ | ------ | ---------------- |
| 单行文本 | `type:input`     | `widget:"type:input"`     | 基础文本输入框 |
| 多行文本 | `mode:text_area`     | `widget:"type:input;mode:text_area"`     | 多行文本区域   |
| 密码输入 | `mode:password`     | `widget:"type:input;mode:password"`     | 密码输入框     |

#### number组件 - 数字输入

| 类型     | 配置 | 示例 | 说明         |
| ---------- | ------ | ------ | -------------- |
| 整数输入 | `type:number`     | `widget:"type:number;min:1;max:120;unit:岁"`     | 整数输入框   |
| 小数输入 | `precision:小数位`     | `widget:"type:number;min:0;precision:2;prefix:￥"`     | 小数输入框   |
| 百分比   | `suffix:%`     | `widget:"type:number;min:0;max:100;precision:1;suffix:%"`     | 百分比输入框 |

#### select组件 - 下拉选择

| 类型     | 配置 | 示例 | 说明       |
| ---------- | ------ | ------ | ------------ |
| 单选下拉 | `type:select`     | `widget:"type:select;options:男,女"`     | 单选下拉框 |
| 多选下拉 | `multiple:true`     | `widget:"type:select;options:技术,产品,设计;multiple:true"`     | 多选下拉框 |

#### datetime组件 - 日期时间

| 类型     | 配置 | 示例 | 说明           |
| ---------- | ------ | ------ | ---------------- |
| 日期选择 | `kind:date`     | `widget:"type:datetime;kind:date;format:yyyy-MM-dd"`     | 日期选择器     |
| 时间选择 | `kind:time`     | `widget:"type:datetime;kind:time;format:HH:mm"`     | 时间选择器     |
| 日期时间 | `kind:datetime`     | `widget:"type:datetime;kind:datetime"`     | 日期时间选择器 |
| 日期范围 | `kind:daterange`     | `widget:"type:datetime;kind:daterange;format:yyyy-MM-dd"`     | 日期范围选择器 |

### 高级组件

#### multiselect组件 - 多选组件

| 配置         | 示例 | 说明               |
| -------------- | ------ | -------------------- |
| 静态多选     | `widget:"type:multiselect;options:紧急,重要,API,UI"`     | 固定选项多选       |
| 可创建新选项 | `widget:"type:multiselect;options:Java,Python,Go;allow_create:true"`     | 支持自定义创建选项 |

#### color组件 - 颜色选择器

| 格式     | 配置 | 示例 | 说明         |
| ---------- | ------ | ------ | -------------- |
| Hex格式  | `format:hex`     | `widget:"type:color;format:hex;show_alpha:false"`     | 6位hex颜色   |
| RGBA格式 | `format:rgba`     | `widget:"type:color;format:rgba;show_alpha:true"`     | RGBA颜色格式 |
| HSL格式  | `format:hsl`     | `widget:"type:color;format:hsl;show_alpha:false"`     | HSL颜色格式  |

#### file_upload组件 - 文件上传

| 配置       | 示例 | 说明       |
| ------------ | ------ | ------------ |
| 单文件上传 | `widget:"type:file_upload;accept:.jpg,.png;max_size:5MB"`     | 单文件上传 |
| 多文件上传 | `widget:"type:file_upload;accept:.pdf,.doc;multiple:true;max_size:10MB"`     | 多文件上传 |

#### list组件 - 列表输入

| 类型     | 示例 | 说明             |
| ---------- | ------ | ------------------ |
| 简单列表 | `widget:"type:list"`     | 字符串或数字列表 |
| 复杂列表 | `widget:"type:list"`     | 结构体列表       |

#### form组件 - 嵌套表单

| 示例 | 说明                               |
| ------ | ------------------------------------ |
| `widget:"type:form"`     | 嵌套表单结构，对应数据结构是结构体 |

### 其他组件

#### switch组件 - 开关

| 配置       | 示例 | 说明           |
| ------------ | ------ | ---------------- |
| 基础开关   | `widget:"type:switch"`     | 布尔值开关     |
| 自定义标签 | `widget:"type:switch;true_label:启用;false_label:禁用"`     | 自定义开关标签 |

#### radio组件 - 单选框

| 配置       | 示例 | 说明               |
| ------------ | ------ | -------------------- |
| 基础单选框 | `widget:"type:radio;options:男,女"`     | 单选按钮组         |
| 水平排列   | `widget:"type:radio;options:男,女;direction:horizontal"`     | 水平排列的单选按钮 |

#### checkbox组件 - 复选框

| 配置       | 示例 | 说明         |
| ------------ | ------ | -------------- |
| 基础复选框 | `widget:"type:checkbox;options:阅读,音乐,运动"`     | 多选复选框组 |

#### slider组件 - 滑块

| 配置     | 示例 | 说明             |
| ---------- | ------ | ------------------ |
| 数值滑块 | `widget:"type:slider;min:0;max:100;unit:%"`     | 数值范围滑块     |
| 评分滑块 | `widget:"type:slider;min:1;max:5;step:0.5;unit:分"`     | 带步进的评分滑块 |

## 📝 使用示例

### 基础字段配置

## Form函数模型示例 - 大模型代码生成模板

#### 用户注册模型

```go
// 请求结构体 - 用户输入
type UserRegisterReq struct {
    // 基础信息
    Username string `json:"username" runner:"name:用户名" widget:"type:input" data:"example:john_doe" validate:"required,min=3,max=20"`
    Password string `json:"password" runner:"name:密码" widget:"type:input;mode:password" data:"example:123456" validate:"required,min=6,max=20"`
    Email    string `json:"email" runner:"name:邮箱" widget:"type:input" data:"example:john@example.com" validate:"required,email"`
    
    // 个人信息
    RealName string `json:"real_name" runner:"name:真实姓名" widget:"type:input" data:"example:张三" validate:"required,min=2,max=20"`
    Age      int    `json:"age" runner:"name:年龄" widget:"type:number;min:18;max:65;unit:岁" data:"example:25" validate:"required,min=18,max=65"`
    Gender   string `json:"gender" runner:"name:性别" widget:"type:radio;options:男,女;direction:horizontal" data:"example:男" validate:"required,oneof=男 女"`
    
    // 工作信息
    Department string `json:"department" runner:"name:部门" widget:"type:select;options:技术部,产品部,设计部,运营部" data:"default_value:技术部" validate:"required"`
    Position   string `json:"position" runner:"name:职位" widget:"type:input" data:"example:软件工程师" validate:"required"`
    Salary     int    `json:"salary" runner:"name:期望薪资" widget:"type:number;min:3000;max:50000;unit:元" data:"example:15000" validate:"required,min=3000,max=50000"`
    
    // 技能标签
    Skills []string `json:"skills" runner:"name:技能标签" widget:"type:multiselect;options:Java,Python,Go,JavaScript,React,Vue" data:"example:Java,Go" validate:"required,min=1"`
    
    // 附件上传
    Resume *files.Files `json:"resume" runner:"name:简历" widget:"type:file_upload;accept:.pdf,.doc,.docx;max_size:10MB" validate:"required"`
    Avatar *files.Files `json:"avatar" runner:"name:头像" widget:"type:file_upload;accept:.jpg,.png,.gif;max_size:5MB"`
    
    // 其他信息
    Bio       string `json:"bio" runner:"name:个人简介" widget:"type:input;mode:text_area" data:"example:热爱编程，有3年开发经验"`
    AgreeTerms bool  `json:"agree_terms" runner:"name:同意条款" widget:"type:switch;true_label:同意;false_label:不同意" data:"example:true" validate:"required"`
}

// 响应结构体 - 处理结果
type UserRegisterResp struct {
    // 处理结果
    Success   bool   `json:"success" runner:"name:是否成功" widget:"type:switch;true_label:成功;false_label:失败"`
    Message   string `json:"message" runner:"name:处理结果" widget:"type:input;mode:text_area"`
    
    // 用户信息
    UserID    int    `json:"user_id" runner:"name:用户ID" widget:"type:number"`
    Username  string `json:"username" runner:"name:用户名" widget:"type:input"`
    
    // 系统信息
    CreatedAt int64  `json:"created_at" runner:"name:注册时间" widget:"type:datetime;kind:datetime"`
    Token     string `json:"token" runner:"name:访问令牌" widget:"type:input;mode:password"`
}
```

#### 采购申请模型

```go
// 请求结构体 - 采购申请
type PurchaseReq struct {
    // 基础信息
    Title       string `json:"title" runner:"name:采购标题" widget:"type:input" data:"example:办公用品采购" validate:"required,min=5,max=100"`
    Department  string `json:"department" runner:"name:申请部门" widget:"type:select;options:技术部,产品部,设计部,运营部" validate:"required"`
    Priority    string `json:"priority" runner:"name:优先级" widget:"type:select;options:低,中,高,紧急" data:"default_value:中" validate:"required"`
    
    // 供应商信息
    SupplierID int `json:"supplier_id" runner:"name:供应商" widget:"type:select" validate:"required"`
    
    // 采购商品列表
    Items []PurchaseItem `json:"items" runner:"name:采购商品" widget:"type:list" validate:"required,min=1"`
    
    // 其他信息
    ExpectedDate int64  `json:"expected_date" runner:"name:期望到货日期" widget:"type:datetime;kind:date;format:yyyy-MM-dd" validate:"required"`
    Remarks      string `json:"remarks" runner:"name:备注说明" widget:"type:input;mode:text_area"`
}

// 采购商品项
type PurchaseItem struct {
    ProductID int     `json:"product_id" runner:"name:商品" widget:"type:select" validate:"required"`
    Quantity  int     `json:"quantity" runner:"name:数量" widget:"type:number;min:1" data:"default_value:1" validate:"required,min=1"`
    UnitPrice float64 `json:"unit_price" runner:"name:单价" widget:"type:number;min:0;precision:2;prefix:￥" validate:"required,min=0"`
    Remarks   string  `json:"remarks" runner:"name:备注" widget:"type:input"`
}

// 响应结构体 - 采购结果
type PurchaseResp struct {
    // 处理结果
    Success      bool   `json:"success" runner:"name:是否成功" widget:"type:switch;true_label:成功;false_label:失败"`
    Message      string `json:"message" runner:"name:处理结果" widget:"type:input;mode:text_area"`
    
    // 采购信息
    PurchaseID   int     `json:"purchase_id" runner:"name:采购单号" widget:"type:number"`
    TotalAmount  float64 `json:"total_amount" runner:"name:总金额" widget:"type:number;precision:2;prefix:￥"`
    TotalItems   int     `json:"total_items" runner:"name:商品种类" widget:"type:number"`
    
    // 状态信息
    Status       string `json:"status" runner:"name:采购状态" widget:"type:input"`
    CreatedAt    int64  `json:"created_at" runner:"name:创建时间" widget:"type:datetime;kind:datetime"`
}
```

### **2. Table函数模型示例**

#### 用户管理模型

```go
// 用户数据模型 - 自动建表
type CRMUser struct {
    // 系统字段
    ID        int            `json:"id" gorm:"primaryKey;autoIncrement" runner:"name:用户ID" permission:"read"`
    CreatedAt int64          `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" widget:"type:datetime;kind:datetime" permission:"read"`
    UpdatedAt int64          `json:"updated_at" gorm:"autoUpdateTime:milli" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read"`
    DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index" runner:"-"`

    // 基础信息
    Username string `json:"username" gorm:"column:username;uniqueIndex" runner:"name:用户名" widget:"type:input" search:"like" validate:"required,min=3,max=20"`
    Email    string `json:"email" gorm:"column:email;uniqueIndex" runner:"name:邮箱" widget:"type:input" search:"like" validate:"required,email"`
    Phone    string `json:"phone" gorm:"column:phone" runner:"name:手机号" widget:"type:input" search:"like" validate:"required,min=11,max=11"`
    
    // 个人信息
    RealName   string `json:"real_name" gorm:"column:real_name" runner:"name:真实姓名" widget:"type:input" search:"like" validate:"required,min=2,max=20"`
    Age        int    `json:"age" gorm:"column:age" runner:"name:年龄" widget:"type:number;min:18;max:65;unit:岁" search:"gte,lte" validate:"required,min=18,max=65"`
    Gender     string `json:"gender" gorm:"column:gender" runner:"name:性别" widget:"type:select;options:男,女" search:"in" validate:"required,oneof=男 女"`
    Avatar     string `json:"avatar" gorm:"column:avatar" runner:"name:头像" widget:"type:input"`
    
    // 工作信息
    Department string `json:"department" gorm:"column:department" runner:"name:部门" widget:"type:select;options:技术部,产品部,设计部,运营部" search:"in" validate:"required"`
    Position   string `json:"position" gorm:"column:position" runner:"name:职位" widget:"type:input" search:"like" validate:"required"`
    Salary     int    `json:"salary" gorm:"column:salary" runner:"name:薪资" widget:"type:number;min:3000;max:50000;unit:元" search:"gte,lte" validate:"required,min=3000,max=50000"`
    
    // 状态信息
    Status     string `json:"status" gorm:"column:status" runner:"name:状态" widget:"type:select;options:在职,离职,试用期" data:"default_value:在职" search:"in" validate:"required"`
    IsActive   bool   `json:"is_active" gorm:"column:is_active" runner:"name:是否启用" widget:"type:switch;true_label:启用;false_label:禁用" data:"default_value:true" search:"eq" validate:"required"`
    
    // 敏感信息 - 仅新增和编辑时显示
    Password   string `json:"password" gorm:"column:password" runner:"name:密码" widget:"type:input;mode:password" permission:"create,update"`
}

func (User) TableName() string { return "crm_user" }

// 请求结构体 - 分页搜索
type CRMUserListReq struct {
    query.SearchFilterPageReq `runner:"-"`
    
    // 自定义搜索字段，这里的字段是不存在于上面表中的字段，存在表中的字段可以直接打标签支持各种搜索，
	//下面的搜索字段一般是join字段，例如 用户关联组织表，然后下面可以用组织表的字段，然后在处理函数用该字段进行连表查询
    OrgName string `json:"org_name" runner:"name:组织名称" widget:"type:input" search:"like"`
}
```

#### 产品管理模型

```go
// 产品数据模型 - 自动建表
type Product struct {
    // 系统字段
    ID        int            `json:"id" gorm:"primaryKey;autoIncrement" runner:"name:产品ID" permission:"read"`
    CreatedAt int64          `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" widget:"type:datetime;kind:datetime" permission:"read"`
    UpdatedAt int64          `json:"updated_at" gorm:"autoUpdateTime:milli" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read"`
    DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index" runner:"-"`

    // 基础信息
    Name        string  `json:"name" gorm:"column:name" runner:"name:产品名称" widget:"type:input" search:"like" validate:"required,min=2,max=100"`
    Code        string  `json:"code" gorm:"column:code;uniqueIndex" runner:"name:产品编码" widget:"type:input" search:"like" validate:"required,min=3,max=20"`
    Category    string  `json:"category" gorm:"column:category" runner:"name:产品分类" widget:"type:select;options:电子产品,服装,食品,家居,其他" search:"in" validate:"required"`
    
    // 规格信息
    Brand       string  `json:"brand" gorm:"column:brand" runner:"name:品牌" widget:"type:input" search:"like" validate:"required"`
    Model       string  `json:"model" gorm:"column:model" runner:"name:型号" widget:"type:input" search:"like"`
    Spec        string  `json:"spec" gorm:"column:spec" runner:"name:规格" widget:"type:input" search:"like"`
    Unit        string  `json:"unit" gorm:"column:unit" runner:"name:单位" widget:"type:input" search:"like" validate:"required"`
    
    // 价格信息
    CostPrice   float64 `json:"cost_price" gorm:"column:cost_price" runner:"name:成本价" widget:"type:number;min:0;precision:2;prefix:￥" search:"gte,lte" validate:"required,min=0"`
    SalePrice   float64 `json:"sale_price" gorm:"column:sale_price" runner:"name:销售价" widget:"type:number;min:0;precision:2;prefix:￥" search:"gte,lte" validate:"required,min=0"`
    MarketPrice float64 `json:"market_price" gorm:"column:market_price" runner:"name:市场价" widget:"type:number;min:0;precision:2;prefix:￥" search:"gte,lte"`
    
    // 库存信息
    Stock       int     `json:"stock" gorm:"column:stock" runner:"name:库存" widget:"type:number;min:0;unit:件" search:"gte,lte" validate:"required,min=0"`
    MinStock    int     `json:"min_stock" gorm:"column:min_stock" runner:"name:最低库存" widget:"type:number;min:0;unit:件" data:"default_value:10" validate:"required,min=0"`
    
    // 状态信息
    Status      string  `json:"status" gorm:"column:status" runner:"name:状态" widget:"type:select;options:上架,下架,缺货,停售" data:"default_value:上架" search:"in" validate:"required"`
    IsHot       bool    `json:"is_hot" gorm:"column:is_hot" runner:"name:是否热销" widget:"type:switch;true_label:是;false_label:否" data:"default_value:false" search:"eq"`
    
    // 描述信息
    Description string  `json:"description" gorm:"column:description" runner:"name:产品描述" widget:"type:input;mode:text_area" search:"like"`
    Images      string  `json:"images" gorm:"column:images" runner:"name:产品图片" widget:"type:input"`
}

func (Product) TableName() string { return "product" }

// 请求结构体 - 分页搜索
type ProductListReq struct {
    query.SearchFilterPageReq `runner:"-"`
    
    // 自定义搜索字段
    Category    string   `json:"category" runner:"name:分类筛选" widget:"type:select;options:电子产品,服装,食品,家居,其他" search:"in"`
    Brand       string   `json:"brand" runner:"name:品牌筛选" widget:"type:input" search:"like"`
    PriceRange  []float64 `json:"price_range" runner:"name:价格范围" widget:"type:number;min:0;precision:2" search:"gte,lte"`
    StockStatus string   `json:"stock_status" runner:"name:库存状态" widget:"type:select;options:充足,不足,缺货" search:"in"`
}
```

### Form函数配置模板

```go
var YourFormOption = &runner.FormFunctionOptions{
    BaseConfig: runner.BaseConfig{
        ChineseName: "功能名称",
        ApiDesc:     "功能描述",
        Tags:        []string{"标签1", "标签2"},
        Request:     &YourReq{},
        Response:    &YourResp{},
        CreateTables: []interface{}{&YourModel{}}, // 如果需要建表
        Group:       YourGroup, // 如果使用函数组
    },
    
	// 如果需要模糊搜索
	OnInputFuzzyMap: map[string]runner.OnInputFuzzy{
		"field_name": func(ctx *runner.Context, req *usercall.OnInputFuzzyReq) (*usercall.OnInputFuzzyResp, error) {
			// 【当前场景】field_name是单选字段，只返回静态信息，不做聚合计算
			// 【目标字段】为 YourReq.FieldName 提供数据选择
			var items []YourModel
			db := ctx.MustGetOrInitDB()

			if req.IsByFiledValues() {
				// 多值查询：使用 IN 查询，这里必须用 db = db.Where
				db = db.Where("id in ?", req.GetFiledValues())
			} else if req.IsByFiledValue() {
				// 单值查询：使用等值查询，性能最优
				db = db.Where("id = ?", req.GetFiledValue()).Limit(1)
			} else {
				// 模糊查询：关键字搜索
				db = db.Where("name LIKE ? OR category LIKE ?", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%").
					Where("status = ?", "正常").
					Limit(20)
			}
			db.Find(&items)

			// 构建返回数据
			fuzzyItems := make([]*usercall.InputFuzzyItem, 0)
			for _, item := range items {
				fuzzyItems = append(fuzzyItems, &usercall.InputFuzzyItem{
					Value: item.ID,
					Label: fmt.Sprintf("%s - %s", item.Name, item.Description),
					DisplayInfo: map[string]interface{}{
						"名称": item.Name,
						"描述": item.Description,
						"状态": item.Status,
					},
				})
			}

			return &usercall.OnInputFuzzyResp{
				Statistics: map[string]interface{}{
					"配送方式": "顺丰快递",
					"保质期": "12个月",
					"会员折扣": "9折优惠",
				},
				Values: fuzzyItems,
			}, nil
		},
	},
}
```

### Table函数配置模板

```go
var YourTableOption = &runner.TableFunctionOptions{
    BaseConfig: runner.BaseConfig{
        ChineseName:  "功能名称",
        ApiDesc:      "功能描述",
        Tags:         []string{"标签1", "标签2"},
        Request:      &YourListReq{},
        Response:     query.PaginatedTable[[]YourModel]{},
        CreateTables: []interface{}{&YourModel{}},
        Group:        YourGroup, // 如果使用函数组
    },
    
    // 自动生成CRUD界面
    AutoCrudTable: &YourModel{},
    
    // 如果需要回调
    OnTableAddRows: func(ctx *runner.Context, req *usercall.OnTableAddRowsReq) (*usercall.OnTableAddRowsResp, error) {
        // 实现新增逻辑
        return &usercall.OnTableAddRowsResp{}, nil
    },
    
    OnTableUpdateRows: func(ctx *runner.Context, req *usercall.OnTableUpdateRowsReq) (*usercall.OnTableUpdateRowsResp, error) {
        // 实现更新逻辑
        return &usercall.OnTableUpdateRowsResp{}, nil
    },
    
    OnTableDeleteRows: func(ctx *runner.Context, req *usercall.OnTableDeleteRowsReq) (*usercall.OnTableDeleteRowsResp, error) {
        // 实现删除逻辑
        return &usercall.OnTableDeleteRowsResp{}, nil
    },
}
```

### 权限控制示例

```go
type Product struct {
// 只读字段
ID        int    `json:"id" gorm:"primaryKey" runner:"name:ID" permission:"read"`
CreatedAt int64  `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" permission:"read"`

// 业务字段：全权限
Name      string `json:"name" runner:"name:产品名称" widget:"type:input" search:"like" validate:"required"`
Status    string `json:"status" runner:"name:状态" widget:"type:select;options:启用,禁用" search:"in"`

// 密钥字段：仅编辑时显示（系统自动生成，用户不能修改）
SecretKey string `json:"secret_key" runner:"name:密钥" widget:"type:input;mode:password" permission:"update"`

// 备注字段：仅创建时显示（创建后不能编辑）
Remark    string `json:"remark" runner:"name:创建备注" widget:"type:input;mode:text_area" permission:"create"`
}
```

## Function-Go 命名规范

下面定义了 Function-Go 项目中的命名规范，确保代码的一致性和可维护性（注意：需要严格遵循命名规范）

## 1. 单文件单函数

### 文件命名

```go
// 文件：pdf_to_image.go（具体功能）
package pdf
```

### 路由命名

```go
// 路由和文件名称保持一致
RouterGroup+"/pdf_to_image"
```

### 结构体和函数命名

```go
// 结构体和函数用 PdfToImage 开头（具体功能）
type PdfToImageReq struct { ... }
type PdfToImageResp struct { ... }

func PdfToImage(ctx *runner.Context, req *PdfToImageReq, resp response.Response) error { ... }

var PdfToImageOption = &runner.FormFunctionOptions{ ... }
```

### 完整示例

注意代码第一行必须给出文件名注释

```go
//文件名：pdf_to_image.go
package pdf

import (
    "github.com/yunhanshu-net/function-go/pkg/dto/response"
    "github.com/yunhanshu-net/function-go/runner"
)

// 请求结构体
type PdfToImageReq struct {
    File *files.Files `json:"file" runner:"name:PDF文件" widget:"type:file_upload"`
}

// 响应结构体
type PdfToImageResp struct {
    Result *files.Files `json:"result" runner:"name:转换结果" widget:"type:file_display"`
}

// 处理函数
func PdfToImage(ctx *runner.Context, req *PdfToImageReq, resp response.Response) error {
    // PDF转图片逻辑
    return resp.Form(&PdfToImageResp{Result: nil}).Build()
}

// 函数配置
var PdfToImageOption = &runner.FormFunctionOptions{
    BaseConfig: runner.BaseConfig{
        ChineseName: "PDF转图片",
        Request:     &PdfToImageReq{},
        Response:    &PdfToImageResp{},
    },
}

// 路由注册
func init() {
    runner.Post(RouterGroup+"/pdf_to_image", PdfToImage, PdfToImageOption)
}
```

## 2. 单文件多函数（需要用函数组）

### 文件命名

```go
// 文件：pdf_tools.go
package pdf
```

### 函数组配置

```go
var PdfToolsGroup = &runner.FunctionGroup{
    CnName: "PDF工具集",
    EnName: "pdf_tools",  // 【框架规范】与文件名一致
}
```

### 路由命名

```go
// 路由用 pdf_tools_xxx 开头
RouterGroup+"/pdf_tools_convert"
RouterGroup+"/pdf_tools_merge"
RouterGroup+"/pdf_tools_split"
```

### 结构体和函数命名

```go
// 结构体和函数用 PdfTools 开头（文件名称的驼峰格式开头）
type PdfToolsConvertReq struct { ... }
type PdfToolsMergeReq struct { ... }
type PdfToolsSplitReq struct { ... }

func PdfToolsConvert(ctx *runner.Context, req *PdfToolsConvertReq, resp response.Response) error { ... }
func PdfToolsMerge(ctx *runner.Context, req *PdfToolsMergeReq, resp response.Response) error { ... }
func PdfToolsSplit(ctx *runner.Context, req *PdfToolsSplitReq, resp response.Response) error { ... }

var PdfToolsConvertOption = &runner.FormFunctionOptions{ ... }
var PdfToolsMergeOption = &runner.FormFunctionOptions{ ... }
var PdfToolsSplitOption = &runner.FormFunctionOptions{ ... }
```

### 完整示例

```go
//文件名：pdf_tools
package pdf

import (
    "github.com/yunhanshu-net/function-go/pkg/dto/response"
    "github.com/yunhanshu-net/function-go/runner"
)

// 函数组定义
var PdfToolsGroup = &runner.FunctionGroup{
    CnName: "PDF工具集",
    EnName: "pdf_tools",
}

// 转换请求
type PdfToolsConvertReq struct {
    File *files.Files `json:"file" runner:"name:PDF文件" widget:"type:file_upload"`
}

// 转换响应
type PdfToolsConvertResp struct {
    Result *files.Files `json:"result" runner:"name:转换结果" widget:"type:file_display"`
}

// 合并请求
type PdfToolsMergeReq struct {
    Files *files.Files `json:"files" runner:"name:PDF文件" widget:"type:file_upload;multiple:true"`
}

// 合并响应
type PdfToolsMergeResp struct {
    Result *files.Files `json:"result" runner:"name:合并结果" widget:"type:file_display"`
}

// 转换函数
func PdfToolsConvert(ctx *runner.Context, req *PdfToolsConvertReq, resp response.Response) error {
    return resp.Form(&PdfToolsConvertResp{Result: nil}).Build()
}

// 合并函数
func PdfToolsMerge(ctx *runner.Context, req *PdfToolsMergeReq, resp response.Response) error {
    return resp.Form(&PdfToolsMergeResp{Result: nil}).Build()
}

// 函数配置
var PdfToolsConvertOption = &runner.FormFunctionOptions{
    BaseConfig: runner.BaseConfig{
        ChineseName: "PDF格式转换",
        Group:       PdfToolsGroup,
        Request:     &PdfToolsConvertReq{},
        Response:    &PdfToolsConvertResp{},
    },
}

var PdfToolsMergeOption = &runner.FormFunctionOptions{
    BaseConfig: runner.BaseConfig{
        ChineseName: "PDF文件合并",
        Group:       PdfToolsGroup,
        Request:     &PdfToolsMergeReq{},
        Response:    &PdfToolsMergeResp{},
    },
}

// 路由注册
func init() {
    runner.Post(RouterGroup+"/pdf_tools_convert", PdfToolsConvert, PdfToolsConvertOption)
    runner.Post(RouterGroup+"/pdf_tools_merge", PdfToolsMerge, PdfToolsMergeOption)
}
```

## 总结

- **单文件单函数**：具体功能（如 `pdf_to_image.go`），命名用具体功能前缀（如 `PdfToImage`），路由用 `RouterGroup+"/pdf_to_image"`
- **单文件多函数**：抽象工具集（如 `pdf_tools.go`），命名用抽象前缀（如 `PdfTools`），路由用 `RouterGroup+"/pdf_tools_xxx"`，需要用函数组来归类这一系列相关函数
- **命名一致性**：确保文件名、包名、路由名、结构体名、函数名都遵循相同的命名模式

## 🎯 最佳实践

### 1. 标签配置原则

- **必填字段**：添加 `validate:"required"`
- **搜索字段**：根据类型选择合适的 `search` 标签
- **权限控制**：使用 `permission` 标签控制字段显示
- **默认值**：使用 `data:"default_value:值"` 设置默认值

### 2. 组件选择原则

- **文本输入**：使用 `input` 组件
- **数字输入**：使用 `number` 组件
- **选择输入**：使用 `select`、`radio`、`checkbox` 组件
- **日期时间**：使用 `datetime` 组件
- **文件处理**：使用 `file_upload` 组件
- **多选场景**：使用 `multiselect` 组件

### 3. 搜索配置原则

- **文本字段**：使用 `like` 模糊搜索
- **状态字段**：使用 `in` 多选搜索
- **数值字段**：使用 `gte,lte` 区间搜索
- **时间字段**：使用 `gte,lte` 时间范围搜索

### 4. 验证规则原则

- **必填验证**：必填字段必须添加 `required`
- **长度限制**：防止过长输入，使用 `min`、`max`
- **格式验证**：邮箱、URL等特殊格式使用相应验证规则
- **业务规则**：符合实际业务需求的验证规则

## 📋 Function-Go 项目开发 Checklist

### 开发前检查

1. **检查函数、结构体、命名是否规范**

**单文件单函数（table）**
```go
package crm
// 文件名称：crm_ticket.go
// 函数和结构体命名用：CrmTicketXxx 
// 路由用：RouterGroup+"/crm_ticket_list"（table函数路由后面一般加个list）
```

**单文件单函数（form）**
```go
package crm
// 文件名称：crm_ticket.go
// 函数和结构体命名用：CrmTicketXxx 
// 路由用：RouterGroup+"/crm_ticket"（单form函数的路由可以和文件名称对齐）
```

**单文件多函数（table）**
```go
package crm
// 文件名称：crm_ticket.go
// 函数组：crm_ticket
// 函数和结构体命名用：CrmTicketXxx 
// 路由用：
// RouterGroup+"/crm_ticket_list"（table函数）
// RouterGroup+"/crm_ticket_xxxx"
```

**严格遵循命名规范**

2. **检查是否需要使用函数组**（单文件单函数不需要，单文件多函数需要）
3. **检查关联的表是否挂载了对应的结构体，使用Preload防止N+1查询**
4. **检查标签是否使用合理**（widget、validate、search、permission等）
5. **检查回调机制是否正确**（OnInputFuzzy多选才聚合，单选返回静态信息）

### 开发中检查

6. **检查时间字段配置**（系统时间用毫秒，业务日期可用format）
7. **检查文件字段定义**（存数据库用*files.Files+gorm:type:json，仅输入输出用*files.Files）
8. **检查错误处理是否友好**（返回具体错误信息指导用户操作）

### 开发后检查

9. **检查是否配置了CreateTables和AutoCrudTable**
10. **禁止定义RouterGroup变量，因为框架已经定义好了，请直接使用即可**
11. **检查路由注册是否正确**（RouterGroup+"/函数名"）
12. **输出的代码请直接用markdown格式，完整的包裹在```go ``` 标签里，然后代码的开头第一个行必须是//文件名：xxx.go，说明一下这个文件的名称该叫啥**

### 代码输出规范

**代码输出格式要求：**
- 代码必须完整包裹在 ```go ``` 标签中
- 代码第一行必须是 `//文件名：xxx.go` 注释
- 文件名必须与实际的Go文件名一致

## table函数最佳实践的示例

```go
// 文件名：crm_ticket.go
package crm

import (
	"github.com/yunhanshu-net/function-go/pkg/dto/response"
	"github.com/yunhanshu-net/function-go/pkg/dto/usercall"
	"github.com/yunhanshu-net/function-go/runner"
	"github.com/yunhanshu-net/pkg/query"
	"github.com/yunhanshu-net/pkg/typex/files"
	"gorm.io/gorm"
)

// 工单数据模型
type CrmTicket struct {
	// 框架标签：runner:"name:工单ID" - 设置字段在前端的显示名称
	// 框架标签：permission:"read" - 字段只读权限（不能编辑）
	// 注意：gorm:"column:id" 明确指定数据库列名，确保映射正确
	ID int `json:"id" gorm:"primaryKey;autoIncrement;column:id" runner:"name:工单ID" permission:"read"`

	// 框架标签：widget:"type:datetime;kind:datetime" - 日期时间选择器组件
	// 注意：gorm:"autoCreateTime:milli" 自动填充创建时间（毫秒级时间戳，必须是毫秒级别）
	CreatedAt int64 `json:"created_at" gorm:"autoCreateTime:milli;column:created_at" runner:"name:创建时间" widget:"type:datetime;kind:datetime" permission:"read"`

	// 框架标签：widget:"type:datetime;kind:datetime" - 日期时间选择器组件，（毫秒级时间戳，必须是毫秒级别）
	UpdatedAt int64 `json:"updated_at" gorm:"autoUpdateTime:milli;column:updated_at" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read"`

	// 框架标签：runner:"-" - 隐藏字段（不在前端显示）
	DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index;column:deleted_at" runner:"-"`

	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required,min=2,max=200" - 必填字段，长度2-200字符
	Title string `json:"title" gorm:"column:title" runner:"name:工单标题" widget:"type:input" search:"like" validate:"required,min=2,max=200"`

	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：validate:"required,min=10" - 必填字段，至少10字符
	Description string `json:"description" gorm:"column:description" runner:"name:问题描述" widget:"type:input;mode:text_area" validate:"required,min=10"`

	// 框架标签：widget:"type:select;options:低,中,高" - 下拉选择组件（选项：低/中/高）
	// 框架标签：data:"default_value:中" - 设置默认值为"中"
	// 框架标签：validate:"required,oneof=低,中,高" - 必填字段，值必须是选项之一
	Priority string `json:"priority" gorm:"column:priority" runner:"name:优先级" widget:"type:select;options:低,中,高" data:"default_value:中" validate:"required,oneof=低,中,高"`

	// 框架标签：widget:"type:select;options:待处理,处理中,已完成,已关闭" - 下拉选择组件
	// 框架标签：data:"default_value:待处理" - 设置默认状态为"待处理"
	// 框架标签：validate:"required,oneof=待处理,处理中,已完成,已关闭" - 值必须是有效状态
	Status string `json:"status" gorm:"column:status" runner:"name:工单状态" widget:"type:select;options:待处理,处理中,已完成,已关闭" data:"default_value:待处理" validate:"required,oneof=待处理,处理中,已完成,已关闭"`

	// 框架标签：validate:"required,min=11,max=20" - 必填字段，长度11-20字符
	Phone string `json:"phone" gorm:"column:phone" runner:"name:联系电话" widget:"type:input" validate:"required,min=11,max=20"`

	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	Remark string `json:"remark" gorm:"column:remark" runner:"name:备注" widget:"type:input;mode:text_area"`

	//创建用户：用户组件
	CreateBy string `json:"create_by" gorm:"column:create_by" runner:"name:创建用户"  widget:"type:user"`

	// 框架标签：widget:"type:file_upload;multiple:true;..." - 多文件上传组件
	// 框架标签：accept:.pdf,.doc,... - 允许上传的文件类型
	// 注意：gorm:"type:json" 指定数据库存储为JSON类型
	Attachment *files.Files `json:"attachment" gorm:"type:json;column:attachment" runner:"name:附件" widget:"type:file_upload;multiple:true;max_size:10MB;accept:.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.jpg,.png,.gif,.zip,.rar"`
}

// 框架功能：TableName() 指定数据库表名
func (CrmTicket) TableName() string { return "crm_ticket" }

// 分页请求结构
type CrmTicketListReq struct {
	// 框架标签：runner:"-" - 隐藏搜索，分页，等请求参数（无需在前端显示）
	query.SearchFilterPageReq `runner:"-"`
}

// 表格处理函数，这里是前端展示列表数据的接口
func CrmTicketList(ctx *runner.Context, req *CrmTicketListReq, resp response.Response) error {
	// 框架功能：ctx.MustGetOrInitDB() - 获取数据库连接
	db := ctx.MustGetOrInitDB()
	var rows []CrmTicket

	//【框架规范】这里框架会自动拿着请求参数和db去数据库查询数据，自动分页等等
	queryBuilder := resp.Table(&rows).AutoPaginated(db, &CrmTicket{}, &req.SearchFilterPageReq)
	//此时rows，已经是根据请求条件和分页条件查询到的数据了，可以在查询到数据后对数据进行处理等等

	// 框架功能：AutoPaginated() - 自动处理分页/搜索/排序
	return queryBuilder.Build()
}

// 自动CRUD配置
var CrmTicketListOption = &runner.TableFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName: "CRM工单管理",                               // API中文名称
		ApiDesc:     "工单管理系统",                                // API描述
		Tags:        []string{"工单系统", "政务系统", "工单管理", "CRM"}, // 框架自动生成标签分类
		// 框架功能：CreateTables - 服务启动时自动创建数据表
		CreateTables: []interface{}{&CrmTicket{}},
		//对应查询的请求参数
		Request: &CrmTicketListReq{},
		//固定query.PaginatedTable[[]table]{} 的格式
		Response: query.PaginatedTable[[]CrmTicket]{},
	},
	// 框架功能：AutoCrudTable - 自动生成增删改查的界面
	AutoCrudTable: &CrmTicket{},

	//【框架规范】新增记录回调
	OnTableAddRows: func(ctx *runner.Context, req *usercall.OnTableAddRowsReq) (*usercall.OnTableAddRowsResp, error) {
		//【框架规范】这里可以直接获取到gorm的db
		gormDb := ctx.MustGetOrInitDB()
		var addRows []*CrmTicket
		//【框架规范】这里解析用户新增的记录
		if err := req.DecodeBy(&addRows); err != nil {
			return nil, err
		}
		for _, row := range addRows { //如果记录中存在创建用户字段的话，可以从ctx.GetUserInfo()获取用户信息
			row.CreateBy = ctx.GetUserInfo().Username //【框架规范】获取用户信息
		}
		//把记录写入db，写入前后都可以做一些操作
		err := gormDb.Create(&addRows).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableAddRowsResp{}, nil
	},
	//【框架规范】更新记录回调
	OnTableUpdateRows: func(ctx *runner.Context, req *usercall.OnTableUpdateRowsReq) (*usercall.OnTableUpdateRowsResp, error) {
		//【框架规范】这里可以直接获取到gorm的db
		gormDb := ctx.MustGetOrInitDB()
		var updateRow CrmTicket
		if err := req.DecodeBy(&updateRow); err != nil { //这里只能解析到更新的字段的数据，例如更新了phone字段的话，那么其他字段都是空值，只有phone存在值
			return nil, err
		}
		err := gormDb.Where("id in (?)", req.GetIds()).Updates(&updateRow).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableUpdateRowsResp{}, nil
	},

	//【框架规范】删除记录回调
	OnTableDeleteRows: func(ctx *runner.Context, req *usercall.OnTableDeleteRowsReq) (*usercall.OnTableDeleteRowsResp, error) {
		gormDb := ctx.MustGetOrInitDB()
		err := gormDb.Delete(&CrmTicket{}, req.GetIds()).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableDeleteRowsResp{}, nil
	},
}

// 框架功能：init() 函数自动注册路由
func init() {
	// 框架功能：runner.Get() - 注册Table请求路由
	runner.Get(RouterGroup+"/crm_ticket_list", CrmTicketList, CrmTicketListOption)
}

```

form函数最佳实践示例,基本参数输入与输出

```go
// 文件名：text_convert.go
package text

import (
	"strings"
	"github.com/yunhanshu-net/function-go/pkg/dto/response"
	"github.com/yunhanshu-net/function-go/runner"
)

// 【框架功能】Form函数请求结构体：定义用户输入字段，框架自动生成前端表单
type TextConvertReq struct {
	// 【框架标签】widget:"type:input;mode:text_area" - 自动渲染为多行文本输入框
	InputText string `json:"input_text" runner:"name:输入文本" widget:"type:input;mode:text_area" validate:"required"`

	// 【框架标签】widget:"type:select;options:..." - 自动渲染为下拉选择框，data:"default_value"设置默认值
	ConvertType string `json:"convert_type" runner:"name:转换类型" widget:"type:select;options:转大写,转小写,首字母大写" data:"default_value:转大写"`
}

// 【框架功能】Form函数响应结构体：定义返回结果，框架自动渲染前端展示
type TextConvertResp struct {
	// 【框架标签】widget:"type:input;mode:text_area" - 自动渲染为多行文本展示区域
	Result string `json:"result" runner:"name:转换结果" widget:"type:input;mode:text_area"`

	// 【框架标签】widget:"type:input" - 自动渲染为单行文本展示
	Message string `json:"message" runner:"name:状态" widget:"type:input"`
}

// 【框架功能】Form函数处理函数：框架自动调用此函数处理用户请求
func TextConvert(ctx *runner.Context, req *TextConvertReq, resp response.Response) error {
	var result string

	// 业务逻辑：根据转换类型执行文本转换
	switch req.ConvertType {
	case "转大写":
		result = strings.ToUpper(req.InputText)
	case "转小写":
		result = strings.ToLower(req.InputText)
	case "首字母大写":
		result = strings.Title(strings.ToLower(req.InputText))
	default:
		result = req.InputText
	}

	// 【框架功能】resp.Form() - 自动将结果渲染为前端表单展示
	return resp.Form(&TextConvertResp{
		Result:  result,
		Message: "转换完成",
	}).Build()
}

// 【框架功能】Form函数配置：定义API元数据，框架自动生成接口文档和路由
var TextConvertOption = &runner.FormFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName: "文本大小写转换",  // 框架自动生成中文接口名称
		ApiDesc:     "支持文本大小写转换的工具，包括转大写、转小写、首字母大写等功能",  // 框架自动生成API描述
		Tags:        []string{"文本处理", "格式转换", "工具函数"},  // 框架自动生成标签分类
		Request:     &TextConvertReq{},   // 框架自动生成请求参数说明
		Response:    &TextConvertResp{},  // 框架自动生成响应结果说明
	},
}

// 【框架功能】路由注册：框架自动创建RouterGroup 变量，无需自己创建RouterGroup变量，可以直接用
func init() {
	// 【框架功能】runner.Post() - 自动创建POST路由，支持表单提交
	runner.Post(RouterGroup+"/text_convert", TextConvert, TextConvertOption)
}
```

### 示例3：Form函数-pdf加密解密（文件的上传与文件输出）

可以直接用开源的，主流的第三方包，尽量避免使用非主流的第三方包
github.com/pdfcpu/pdfcpu是个go的很主流专业的开源 pdf开源库，可以直接用

```go
// 文件名：pdf.go
package pdf

/*
<metadata>
<需求>
PDF 加密/解密（单文件自包含）：
- 设置/移除PDF口令，支持用户口令与所有者口令（简化：同一口令）
</需求>

</metadata>
*/

import (
	"fmt"
	"os"
	"path/filepath"

	pdfapi "github.com/pdfcpu/pdfcpu/pkg/api"
	pdfmodel "github.com/pdfcpu/pdfcpu/pkg/pdfcpu/model"
	"github.com/yunhanshu-net/function-go/pkg/dto/response"
	"github.com/yunhanshu-net/function-go/runner"
	"github.com/yunhanshu-net/pkg/typex/files"
)

// ============== PDF加密功能 ==============

// PdfEncryptReq PDF加密请求结构体
// 【框架说明】使用files.Files类型接收用户上传的PDF文件，支持多文件批量处理
type PdfEncryptReq struct {
	// 【框架说明】files.Files是function-go框架的标准文件类型，支持多文件上传
	// 【组件说明】file_upload组件：accept限制文件类型为PDF，multiple:true支持多文件
	// 【验证说明】required确保用户必须上传文件，validate标签自动生成前端验证
	Files *files.Files `json:"files" runner:"name:PDF文件" widget:"type:file_upload;accept:.pdf;multiple:true" data:"type:files" validate:"required"`

	// 【框架说明】密码输入字段，使用password模式隐藏用户输入
	// 【验证说明】required必填，min=1确保密码不为空字符串
	Password string `json:"password" runner:"name:口令" widget:"type:input;mode:password" validate:"required,min=1"`
}

// PdfEncryptResp PDF加密响应结构体
// 【框架说明】返回处理后的加密PDF文件，使用file_display组件展示下载链接
type PdfEncryptResp struct {
	// 【框架说明】Result字段包含加密后的PDF文件，用户可以直接下载
	Result *files.Files `json:"result" runner:"name:加密结果" widget:"type:file_display" data:"type:files"`
}

// PdfEncryptHandle PDF加密处理函数
// 【框架说明】Form函数的标准签名：ctx提供上下文，req接收请求，resp构建响应
func PdfEncryptHandle(ctx *runner.Context, req *PdfEncryptReq, resp response.Response) error {
	// 【框架说明】参数验证：检查文件是否上传，密码是否输入
	if req.Files == nil || req.Files.GetFileCount() == 0 {
		return fmt.Errorf("请上传PDF文件")
	}
	if req.Password == "" {
		return fmt.Errorf("请输入加密口令")
	}

	// 【框架说明】资源清理：使用defer确保临时文件被正确清理，防止磁盘空间泄漏
	// 【重要】files.Files.CleanupLocalFiles()清理上传文件的临时副本
	defer req.Files.CleanupLocalFiles()

	// 【框架说明】创建临时工作目录：ctx.FS().TempUniqueDir()是框架提供的安全临时目录API
	// 【参数说明】"pdf_task"是目录前缀，"encrypt"是任务标识，框架自动生成唯一后缀
	// 【安全说明】每次调用生成不同的目录，避免文件冲突和并发问题
	// 【路径示例】生成的目录类似：/tmp/pdf_task_encrypt_abc123def456/
	baseDir, err := ctx.FS().TempUniqueDir("pdf_task", "encrypt")
	if err != nil {
		return err
	}
	// 【框架说明】使用defer确保临时目录被完全删除，包括所有子文件和子目录
	defer os.RemoveAll(baseDir)

	// 【框架说明】创建输出文件集合：ctx.FS().NewTemporaryFiles()创建临时文件管理器
	// 【作用说明】用于收集处理后的文件，最终返回给用户
	out := ctx.FS().NewTemporaryFiles()
	// 【框架说明】清理输出文件的临时副本，防止内存泄漏
	defer out.CleanupLocalFiles()

	// 【第三方库】使用pdfcpu库创建AES-256加密配置
	// 【参数说明】用户口令和所有者口令设为相同值，简化用户操作
	conf := pdfmodel.NewAESConfiguration(req.Password, req.Password, 256)

	// 【框架说明】遍历用户上传的所有PDF文件，逐个处理
	for _, f := range req.Files.GetFiles() {
		// 【框架说明】获取文件的本地路径：f.GetLocalPath(ctx)将内存中的文件写入临时目录
		// 【返回值】inPath是文件在本地文件系统中的完整路径
		inPath, e := f.GetLocalPath(ctx)
		if e != nil {
			return fmt.Errorf("读取PDF失败: %s", f.Name)
		}

		// 【文件处理】构建输出文件路径，使用原文件名但放在临时目录中
		outPath := filepath.Join(baseDir, filepath.Base(inPath))

		// 【第三方库】调用pdfcpu库进行PDF加密
		if e := pdfapi.EncryptFile(inPath, outPath, conf); e != nil {
			return fmt.Errorf("加密失败(%s)：%v", f.Name, e)
		}

		// 【框架说明】将处理后的文件添加到输出集合：out.AddFileFromPath()将本地文件加入结果集
		// 【作用说明】这样用户就能下载到加密后的PDF文件
		if e := out.AddFileFromPath(outPath); e != nil {
			return e
		}
	}

	// 【框架说明】构建响应：resp.Form()创建表单响应，包含处理结果
	// 【返回说明】用户可以在前端看到加密结果并提供下载链接
	return resp.Form(&PdfEncryptResp{Result: out}).Build()
}

// ============== PDF解密功能 ==============

// PdfDecryptReq PDF解密请求结构体
// 【框架说明】结构与加密请求相同，但业务含义不同
type PdfDecryptReq struct {
	// 【框架说明】files.Files支持多文件批量解密，提高处理效率
	Files *files.Files `json:"files" runner:"name:PDF文件" widget:"type:file_upload;accept:.pdf;multiple:true" data:"type:files" validate:"required"`

	// 【框架说明】解密需要提供正确的加密口令
	Password string `json:"password" runner:"name:口令" widget:"type:input;mode:password" validate:"required,min=1"`
}

// PdfDecryptResp PDF解密响应结构体
// 【框架说明】返回解密后的PDF文件，用户可以正常打开和编辑
type PdfDecryptResp struct {
	// 【框架说明】Result字段包含解密后的PDF文件
	Result *files.Files `json:"result" runner:"name:解密结果" widget:"type:file_display" data:"type:files"`
}

// PdfDecryptHandle PDF解密处理函数
// 【框架说明】解密逻辑与加密类似，但调用pdfapi.DecryptFile()函数
func PdfDecryptHandle(ctx *runner.Context, req *PdfDecryptReq, resp response.Response) error {
	// 【框架说明】参数验证逻辑与加密函数相同
	if req.Files == nil || req.Files.GetFileCount() == 0 {
		return fmt.Errorf("请上传PDF文件")
	}
	if req.Password == "" {
		return fmt.Errorf("请输入解密口令")
	}

	// 【框架说明】资源清理：确保上传的临时文件被清理
	defer req.Files.CleanupLocalFiles()

	// 【框架说明】创建解密专用的临时工作目录，避免与加密任务冲突
	// 【命名说明】使用"decrypt"标识，便于调试和日志追踪
	baseDir, err := ctx.FS().TempUniqueDir("pdf_task", "decrypt")
	if err != nil {
		return err
	}
	// 【框架说明】确保临时目录被完全清理
	defer os.RemoveAll(baseDir)

	// 【框架说明】创建输出文件集合，用于收集解密后的文件
	out := ctx.FS().NewTemporaryFiles()
	// 【框架说明】清理输出文件的临时副本
	defer out.CleanupLocalFiles()

	// 【第三方库】使用相同的AES配置进行解密
	conf := pdfmodel.NewAESConfiguration(req.Password, req.Password, 256)

	// 【框架说明】遍历所有PDF文件进行解密处理
	for _, f := range req.Files.GetFiles() {
		// 【框架说明】获取文件的本地路径，准备解密处理
		inPath, e := f.GetLocalPath(ctx)
		if e != nil {
			return fmt.Errorf("读取PDF失败: %s", f.Name)
		}

		// 【文件处理】构建解密后的输出文件路径
		outPath := filepath.Join(baseDir, filepath.Base(inPath))

		// 【第三方库】调用pdfcpu库进行PDF解密
		if e := pdfapi.DecryptFile(inPath, outPath, conf); e != nil {
			return fmt.Errorf("解密失败(%s)：%v", f.Name, e)
		}

		// 【框架说明】将解密后的文件添加到输出集合
		if e := out.AddFileFromPath(outPath); e != nil {
			return e
		}
	}

	// 【框架说明】返回解密结果，用户可以下载解密后的PDF文件
	return resp.Form(&PdfDecryptResp{Result: out}).Build()
}

// ============== 函数组配置 ==============

// 【框架说明】函数组用于管理同文件中的多个相关函数
// 【命名规范】组EnName使用文件名pdf_encrypt，CnName提供中文描述
var PdfEncryptGroup = &runner.FunctionGroup{
	CnName: "PDF工具-加密解密",
	EnName: "pdf",
}

// 【框架说明】PDF加密函数配置：使用FormFunctionOptions因为这是表单处理函数
var PdfEncryptOption = &runner.FormFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "PDF加密",                                   // 【框架说明】API的中文名称，用户友好的显示
		ApiDesc:      "为PDF设置口令（用户与所有者同口令，AES-256）", // 【框架说明】API功能描述
		Tags:         []string{"PDF", "安全"},                     // 【框架说明】标签用于分类和搜索
		Request:      &PdfEncryptReq{},                            // 【框架说明】请求结构体，框架自动生成前端表单
		Response:     &PdfEncryptResp{},                           // 【框架说明】响应结构体，框架自动生成结果展示
		Group:        PdfEncryptGroup,                             // 【框架说明】指定函数组，便于前端分组管理
	},
}

// 【框架说明】PDF解密函数配置：结构与加密函数类似
var PdfDecryptOption = &runner.FormFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "PDF解密",                     // 【框架说明】解密函数的中文名称
		ApiDesc:      "移除PDF口令（需提供正确口令）", // 【框架说明】解密功能描述
		Tags:         []string{"PDF", "安全"},       // 【框架说明】相同的标签分类
		Request:      &PdfDecryptReq{},              // 【框架说明】解密请求结构体
		Response:     &PdfDecryptResp{},             // 【框架说明】解密响应结构体
		Group:        PdfEncryptGroup,               // 【框架说明】使用相同的函数组
	},
}

// ============== 路由注册 ==============

// 【框架说明】init()函数在包初始化时自动执行，注册API路由
// 【路由规范】使用POST方法因为这是文件上传和处理的表单函数
// 【路径说明】RouterGroup+"/pdf_encrypt"确保路由唯一性，避免冲突
func init() {
	// 【框架说明】注册PDF加密API：路径与EnglishName保持一致
	runner.Post(RouterGroup+"/pdf_encrypt", PdfEncryptHandle, PdfEncryptOption)

	// 【框架说明】注册PDF解密API：路径与EnglishName保持一致
	runner.Post(RouterGroup+"/pdf_decrypt", PdfDecryptHandle, PdfDecryptOption)
}


```

### 示例4: Form函数-工作空间管理系统（调用外部API，后台管理类，替代postman类只能程序员用的情况，生成的是非技术人可以用的页面功能）

用户需求：

我有两个api，一个创建工作空间，一个获取工作空间列表，需要你帮我搞成对应的功能，方便用户使用，下面是接口请求示例

1. 创建工作空间

curl 'http://func-ai.geeleo.com/api/v1/runner'
-H 'Content-Type: application/json'
-H 'Token: 这里可以从配置里管理token参数'
--data-raw '{"title":"清华大学科研工作空间","name":"qinghuadaxue_keyan","description":"主要是为了科研"}'
--insecure

返回值：

{
"code": 0,
"msg": "成功",
"data": {
"id": 5
}
}

2. 获取工作空间列表

curl 'http://func-ai.geeleo.com/api/v1/runner?page_size=100'
-H 'Token: 这里可以从配置里管理token参数'
--insecure

返回值：
{
"code": 0,
"msg": "成功",
"data": {
"items": [
{
"id": 1,
"created_at": "2025-09-03 01:06:25",
"updated_at": "2025-09-03 21:18:41",
"created_by": "beiluo",
"title": "测试空间",
"name": "demo6",
"description": "测试",
"version": "v10",
"status": 1,   /1是已经启用，2停用
"runcher_id": null,
"is_public": false

},
{
"id": 2,
"created_at": "2025-09-03 02:03:21",
"updated_at": "2025-09-03 22:53:49",
"created_by": "beiluo",
"title": "test1",
"name": "test1",
"description": "测试",
"version": "v9",
"status": 1,
"runcher_id": null,
"is_public": false

}
],
"current_page": 0,
"total_count": 2,
"total_pages": 1,
"page_size": 100
}
}

```go
// 文件名：workspace_admin_manage.go


package workspace_admin

import (
	"fmt"
	"time"

	"github.com/yunhanshu-net/function-go/pkg/dto/response"
	"github.com/yunhanshu-net/function-go/pkg/dto/usercall"
	"github.com/yunhanshu-net/function-go/runner"
	"github.com/yunhanshu-net/pkg/x/httpx" //调用http的需要用封装的库
)

// ==================== 函数组：工作空间管理 ====================
var WorkspaceAdminManageGroup = &runner.FunctionGroup{CnName: "工作空间管理", EnName: "workspace_admin_manage"}

// ==================== 配置管理：API连接配置 ====================

// <rag-api>
// 工作空间API配置：管理远程API的连接参数，包括域名和Token认证
// 【框架规范】AutoUpdateConfig配置管理：框架提供的配置热更新机制
// 【Why】为什么需要配置管理：外部API的域名、Token等参数经常变化，需要支持动态配置
// 【What】配置管理做什么：提供配置界面，支持配置热更新，自动持久化到本地文件
// 【How】如何使用配置：通过ctx.GetConfig()获取配置，框架自动管理配置生命周期
// 【业务逻辑】定义API连接参数：基础URL、认证Token、超时设置等
// 【数据来源】管理员通过配置界面设置，框架自动持久化到本地文件
// 【使用场景】外部API调用、Token认证、连接测试等远程服务管理场景
type WorkspaceAdminManageAPIConfig struct {
	// API连接配置
	BaseURL string `json:"base_url" runner:"name:API域名" widget:"type:input" data:"default_value:http://func-ai.geeleo.com/api/v1/runner"`
	Token   string `json:"token" runner:"name:认证Token" widget:"type:input;mode:password" data:"default_value:请替换成真实token"`

	// 连接配置
	TimeoutSeconds int `json:"timeout_seconds" runner:"name:超时时间(秒)" widget:"type:number;min:5;max:300" data:"default_value:30"`
}

// </rag-api>

// ==================== 外部API数据结构 ====================

// 外部API返回的工作空间信息结构体（用于解析外部API响应）
type ExternalWorkspaceInfo struct {
	ID          int    `json:"id"`
	CreatedAt   string `json:"created_at"`
	UpdatedAt   string `json:"updated_at"`
	CreatedBy   string `json:"created_by"`
	Title       string `json:"title"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Version     string `json:"version"`
	Status      int    `json:"status"`
	RuncherID   *int   `json:"runcher_id"`
	IsPublic    bool   `json:"is_public"`
}

// 外部API响应结构体
type ExternalAPIResponse struct {
	Code int    `json:"code"`
	Msg  string `json:"msg"`
	Data struct {
		Items       []ExternalWorkspaceInfo `json:"items"`
		CurrentPage int                     `json:"current_page"`
		TotalCount  int                     `json:"total_count"`
		TotalPages  int                     `json:"total_pages"`
		PageSize    int                     `json:"page_size"`
	} `json:"data"`
}

// 创建工作空间API响应
type ExternalCreateResponse struct {
	Code int    `json:"code"`
	Msg  string `json:"msg"`
	Data struct {
		ID int `json:"id"`
	} `json:"data"`
}

// ==================== 用户响应数据结构 ====================

// 返回给用户的工作空间信息结构体（用于form响应）
type WorkspaceInfo struct {
	ID          int    `json:"id" runner:"name:工作空间ID"`
	CreatedAt   string `json:"created_at" runner:"name:创建时间" widget:"type:datetime;kind:datetime"`
	UpdatedAt   string `json:"updated_at" runner:"name:更新时间" widget:"type:datetime;kind:datetime"`
	CreatedBy   string `json:"created_by" runner:"name:创建者" widget:"type:input"`
	Title       string `json:"title" runner:"name:标题" widget:"type:input"`
	Name        string `json:"name" runner:"name:名称" widget:"type:input"`
	Description string `json:"description" runner:"name:描述" widget:"type:input;mode:text_area"`
	Version     string `json:"version" runner:"name:版本" widget:"type:input"`
	Status      string `json:"status" runner:"name:状态" widget:"type:input"` // 转换为字符串显示
	RuncherID   *int   `json:"runcher_id" runner:"name:运行器ID" widget:"type:number"`
	IsPublic    bool   `json:"is_public" runner:"name:是否公开" widget:"type:switch;true_label:公开;false_label:私有"`
}

// ==================== 请求响应结构体 ====================

// <rag-api>
// 创建工作空间请求参数：包含工作空间的基本信息
// 【业务逻辑】系统自动调用外部API创建工作空间，支持Token认证
// 【使用建议】标题和名称建议使用有意义的标识，描述可用于详细说明工作空间用途
type WorkspaceAdminManageCreateReq struct {
	Title       string `json:"title" runner:"name:工作空间标题" widget:"type:input" data:"example:清华大学科研工作空间" validate:"required,min=2,max=100"`
	Name        string `json:"name" runner:"name:工作空间名称" widget:"type:input" data:"example:qinghuadaxue_keyan" validate:"required,min=2,max=50"`
	Description string `json:"description" runner:"name:工作空间描述" widget:"type:input;mode:text_area" data:"example:主要是为了科研"`
}

// </rag-api>

// <rag-api>
// 获取工作空间列表请求参数：支持分页查询
// 【业务逻辑】系统自动调用外部API获取工作空间列表，支持分页和筛选
// 【使用建议】page_size建议根据实际需要设置，避免一次性获取过多数据
type WorkspaceAdminManageListReq struct {
	PageSize int `json:"page_size" runner:"name:每页数量" widget:"type:number;min:1;max:1000;unit:个" data:"default_value:20;example:100" validate:"required,min=1,max=1000"`
}

// </rag-api>

// <rag-api>
// 创建工作空间响应结果：包含操作结果、工作空间ID、API状态等
// 【业务逻辑】根据API调用结果返回创建成功的工作空间ID和状态信息
// 【使用建议】通过响应信息了解创建结果，工作空间ID用于后续操作
type WorkspaceAdminManageCreateResp struct {
	Message     string `json:"message" runner:"name:操作结果" widget:"type:input;mode:text_area"`
	APIStatus   string `json:"api_status" runner:"name:API状态" widget:"type:input"`
	ConfigInfo  string `json:"config_info" runner:"name:配置信息" widget:"type:input"`
	WorkspaceID int    `json:"workspace_id" runner:"name:工作空间ID" widget:"type:number"`
}

// 获取工作空间列表响应结果：包含操作结果、工作空间列表、分页信息、API状态等
// 【业务逻辑】根据API调用结果返回工作空间列表和分页信息
// 【使用建议】通过响应信息了解查询结果，分页信息用于前端展示
type WorkspaceAdminManageListResp struct {
	Message     string          `json:"message" runner:"name:操作结果" widget:"type:input;mode:text_area"`
	APIStatus   string          `json:"api_status" runner:"name:API状态" widget:"type:input"`
	ConfigInfo  string          `json:"config_info" runner:"name:配置信息" widget:"type:input"`
	Workspaces  []WorkspaceInfo `json:"workspaces" runner:"name:工作空间列表" widget:"type:list"`
	TotalCount  int             `json:"total_count" runner:"name:总数量" widget:"type:number"`
	CurrentPage int             `json:"current_page" runner:"name:当前页" widget:"type:number"`
	TotalPages  int             `json:"total_pages" runner:"name:总页数" widget:"type:number"`
	PageSize    int             `json:"page_size" runner:"name:每页数量" widget:"type:number"`
}

// </rag-api>

// ==================== 工具函数：数据转换和API调用 ====================

// Token验证函数：检查用户是否设置了真实的Token
func validateToken(config WorkspaceAdminManageAPIConfig) error {
	// 检查Token是否为空或默认值
	if config.Token == "" {
		return fmt.Errorf("Token不能为空，请在配置中设置真实的API Token")
	}

	// 检查是否为默认提示文本
	if config.Token == "请替换成真实token" {
		return fmt.Errorf("请将Token替换为真实的API Token，当前使用的是默认提示文本")
	}

	// 检查Token长度是否合理（至少8位）
	if len(config.Token) < 8 {
		return fmt.Errorf("Token长度过短，请检查是否设置了正确的API Token")
	}

	return nil
}

// 数据转换函数：将外部API数据转换为用户友好的格式
func convertExternalToWorkspaceInfo(external ExternalWorkspaceInfo) WorkspaceInfo {
	// 状态转换：1=启用，2=停用
	statusText := "停用"
	if external.Status == 1 {
		statusText = "启用"
	}

	return WorkspaceInfo{
		ID:          external.ID,
		CreatedAt:   external.CreatedAt,
		UpdatedAt:   external.UpdatedAt,
		CreatedBy:   external.CreatedBy,
		Title:       external.Title,
		Name:        external.Name,
		Description: external.Description,
		Version:     external.Version,
		Status:      statusText,
		RuncherID:   external.RuncherID,
		IsPublic:    external.IsPublic,
	}
}

// ==================== 核心业务逻辑：工作空间管理 ====================

// ==================== 框架适配层：Form函数 ====================

// 创建工作空间
// 【框架说明】Form函数：处理工作空间创建请求，调用外部API创建工作空间
// 【业务逻辑】内联业务逻辑，方便大模型学习和理解完整的工作空间创建流程
func WorkspaceAdminManageCreate(ctx *runner.Context, req *WorkspaceAdminManageCreateReq, resp response.Response) error {
	// 【框架规范】配置获取：从上下文获取配置信息
	// 【Why】为什么需要配置：外部API的域名、Token等参数需要动态配置，不能硬编码
	// 【What】配置获取做什么：从框架配置管理中获取API连接参数
	// 【How】如何使用：ctx.GetConfig().(配置结构体类型)，框架自动管理配置生命周期
	config := ctx.GetConfig().(WorkspaceAdminManageAPIConfig)

	// 【业务逻辑】Token验证：检查配置是否有效
	if err := validateToken(config); err != nil {
		return resp.Form(&WorkspaceAdminManageCreateResp{
			Message:    err.Error(),
			APIStatus:  "配置错误",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 构建API URL
	apiURL := config.BaseURL

	// 构建请求体，也可以直接用req
	requestBody := map[string]interface{}{
		"title":       req.Title,
		"name":        req.Name,
		"description": req.Description,
	}

	// 【框架规范】httpx库使用：框架提供的HTTP客户端库
	// 【Why】为什么用httpx：支持链式调用、直接绑定响应结构体、统一错误处理
	// 【What】httpx做什么：提供优雅的HTTP请求API，支持GET/POST/PUT/DELETE等方法
	// 【How】如何使用：链式调用Post().Header().Timeout().Body().Do(响应结构体)
	// 【业务逻辑】POST请求创建工作空间，包含完整的请求头设置和错误处理
	var apiResp ExternalCreateResponse
	httpResult, err := httpx.Post(apiURL).
		Header("Content-Type", "application/json").
		Header("Token", config.Token).
		Timeout(time.Duration(config.TimeoutSeconds) * time.Second).
		Body(requestBody).
		Do(&apiResp)

	if err != nil {
		return resp.Form(&WorkspaceAdminManageCreateResp{
			Message:    fmt.Sprintf("创建工作空间失败: %v", err),
			APIStatus:  "连接失败",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 检查HTTP状态码
	if !httpResult.OK() {
		return resp.Form(&WorkspaceAdminManageCreateResp{
			Message:    fmt.Sprintf("API返回错误状态码: %d, 响应: %s", httpResult.Code, httpResult.ResBodyString),
			APIStatus:  "HTTP错误",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 检查API返回状态
	if apiResp.Code != 0 {
		return resp.Form(&WorkspaceAdminManageCreateResp{
			Message:    fmt.Sprintf("API返回错误: %s", apiResp.Msg),
			APIStatus:  "API业务错误",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 构建成功响应
	result := &WorkspaceAdminManageCreateResp{
		Message:    fmt.Sprintf("工作空间创建成功！ID: %d", apiResp.Data.ID),
		APIStatus:  "调用成功",
		ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
	}

	return resp.Form(result).Build()
}

// 获取工作空间列表
// 【框架说明】Form函数：处理工作空间列表查询请求，调用外部API获取列表数据
// 【业务逻辑】内联业务逻辑，方便大模型学习和理解完整的工作空间查询流程
func WorkspaceAdminManageList(ctx *runner.Context, req *WorkspaceAdminManageListReq, resp response.Response) error {
	// 【框架规范】配置获取：从上下文获取配置信息
	// 【Why】为什么需要配置：外部API的域名、Token等参数需要动态配置，不能硬编码
	// 【What】配置获取做什么：从框架配置管理中获取API连接参数
	// 【How】如何使用：ctx.GetConfig().(配置结构体类型)，框架自动管理配置生命周期
	config := ctx.GetConfig().(WorkspaceAdminManageAPIConfig)

	// 【业务逻辑】Token验证：检查配置是否有效
	if err := validateToken(config); err != nil {
		return resp.Form(&WorkspaceAdminManageListResp{
			Message:    err.Error(),
			APIStatus:  "配置错误",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 构建API URL
	apiURL := fmt.Sprintf("%s?page_size=%d", config.BaseURL, req.PageSize)

	// 【框架规范】httpx库使用：框架提供的HTTP客户端库
	// 【Why】为什么用httpx：支持链式调用、直接绑定响应结构体、统一错误处理
	// 【What】httpx做什么：提供优雅的HTTP请求API，支持GET/POST/PUT/DELETE等方法
	// 【How】如何使用：链式调用Get().Header().Timeout().Do(响应结构体)
	// 【业务逻辑】GET请求获取工作空间列表，包含完整的请求头设置和错误处理
	var apiResp ExternalAPIResponse
	httpResult, err := httpx.Get(apiURL).
		Header("Content-Type", "application/json").
		Header("Token", config.Token).
		Timeout(time.Duration(config.TimeoutSeconds) * time.Second).
		Do(&apiResp)

	if err != nil {
		return resp.Form(&WorkspaceAdminManageListResp{
			Message:    fmt.Sprintf("获取工作空间列表失败: %v", err),
			APIStatus:  "连接失败",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 检查HTTP状态码
	if !httpResult.OK() {
		return resp.Form(&WorkspaceAdminManageListResp{
			Message:    fmt.Sprintf("API返回错误状态码: %d, 响应: %s", httpResult.Code, httpResult.ResBodyString),
			APIStatus:  "HTTP错误",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 检查API返回状态
	if apiResp.Code != 0 {
		return resp.Form(&WorkspaceAdminManageListResp{
			Message:    fmt.Sprintf("API返回错误: %s", apiResp.Msg),
			APIStatus:  "API业务错误",
			ConfigInfo: fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
		}).Build()
	}

	// 转换数据格式
	workspaces := make([]WorkspaceInfo, 0, len(apiResp.Data.Items))
	for _, external := range apiResp.Data.Items {
		workspaces = append(workspaces, convertExternalToWorkspaceInfo(external))
	}

	// 构建成功响应
	result := &WorkspaceAdminManageListResp{
		Message:     fmt.Sprintf("成功获取 %d 个工作空间", len(workspaces)),
		Workspaces:  workspaces,
		TotalCount:  apiResp.Data.TotalCount,
		CurrentPage: apiResp.Data.CurrentPage,
		TotalPages:  apiResp.Data.TotalPages,
		PageSize:    apiResp.Data.PageSize,
		APIStatus:   "调用成功",
		ConfigInfo:  fmt.Sprintf("API: %s, 超时: %ds", config.BaseURL, config.TimeoutSeconds),
	}

	return resp.Form(result).Build()
}

// ==================== 配置和注册 ====================

// 创建工作空间配置
var WorkspaceAdminManageCreateOption = &runner.FormFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName: "工作空间管理-创建",
		ApiDesc:     "创建工作空间，支持设置标题、名称、描述等基本信息。",
		Tags:        []string{"工作空间管理", "创建", "API调用"},
		Request:     &WorkspaceAdminManageCreateReq{},
		Response:    &WorkspaceAdminManageCreateResp{},
		Group:       WorkspaceAdminManageGroup,
		AutoUpdateConfig: &runner.AutoUpdateConfig{ //【框架规范】如果需要配置管理功能需要用这个，ConfigStruct是对应的配置，框架会自动热更新配置
			ConfigStruct: WorkspaceAdminManageAPIConfig{
				BaseURL:        "http://func-ai.geeleo.com/api/v1/runner",
				Token:          "请替换成真实token",
				TimeoutSeconds: 30,
			},
		},
	},
	// 【框架规范】DryRun回调：框架提供的API测试机制
	// 【Why】为什么需要DryRun：POST等写操作有风险，需要先测试连接和参数，避免误操作
	// 【What】DryRun做什么：模拟API调用，测试连接状态，验证参数格式，不执行实际业务
	// 【How】如何使用DryRun：前端自动提供DryRun按钮，点击后触发OnDryRun回调
	// 【触发时机】用户点击DryRun按钮时自动触发，无需用户输入DryRun参数
	// 【返回要求】必须返回Valid状态和测试案例，框架自动展示测试结果
	OnDryRun: func(ctx *runner.Context, req *usercall.OnDryRunReq) (*usercall.OnDryRunResp, error) {
		// 【框架规范】配置获取：从上下文获取配置信息
		config := ctx.GetConfig().(WorkspaceAdminManageAPIConfig)

		// 【业务逻辑】Token验证：检查配置是否有效
		if err := validateToken(config); err != nil {
			return &usercall.OnDryRunResp{
				Valid:   false,
				Message: err.Error(),
			}, nil
		}

		// 【框架规范】参数解码：从请求中解码用户输入参数
		var createReq WorkspaceAdminManageCreateReq
		if err := req.DecodeBody(&createReq); err != nil {
			return &usercall.OnDryRunResp{
				Valid:   false,
				Message: fmt.Sprintf("参数解码失败: %v", err),
			}, nil
		}

		// 【框架规范】httpx DryRun：使用httpx库构建测试案例
		// 【Why】为什么用httpx：httpx提供ConnectivityCheck()和DryRun()方法，自动测试连接
		// 【What】httpx DryRun做什么：模拟HTTP请求，测试网络连接，验证请求格式
		// 【How】如何使用：链式调用Post().Header().Body().ConnectivityCheck().DryRun()
		// 【ConnectivityCheck底层实现】通过HEAD方法测试接口可用性和网络连通性
		// 【环境痛点解决】即使代码正确，环境问题（网络、防火墙、DNS等）也会导致API调用失败
		// 【用户价值】让用户提前发现环境问题，避免实际执行时的失败，提供保险机制
		dryRunCase := httpx.Post(config.BaseURL).
			Header("Content-Type", "application/json").
			Header("Token", config.Token).
			Timeout(time.Duration(config.TimeoutSeconds) * time.Second).
			Body(createReq).
			ConnectivityCheck().
			DryRun()

		// 【框架规范】DryRun响应：返回测试结果和案例
		return &usercall.OnDryRunResp{
			Valid:   true,
			Message: fmt.Sprintf("预览创建工作空间：%s (%s)", createReq.Title, createReq.Name),
			Cases:   []usercall.DryRunCase{dryRunCase},
		}, nil
	},
}

// 获取工作空间列表配置
var WorkspaceAdminManageListOption = &runner.FormFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName: "工作空间管理-列表",
		ApiDesc:     "获取工作空间列表，支持分页查询和详细信息展示。",
		Tags:        []string{"工作空间管理", "列表", "API调用"},
		Request:     &WorkspaceAdminManageListReq{},
		Response:    &WorkspaceAdminManageListResp{},
		Group:       WorkspaceAdminManageGroup,
		AutoUpdateConfig: &runner.AutoUpdateConfig{
			ConfigStruct: WorkspaceAdminManageAPIConfig{ //【框架规范】如果需要配置管理功能需要用这个，ConfigStruct是对应的配置，框架会自动热更新配置
				BaseURL:        "http://func-ai.geeleo.com/api/v1/runner",
				Token:          "请替换成真实token",
				TimeoutSeconds: 30,
			},
		},
	},
	// 【框架规范】DryRun回调：框架提供的API测试机制
	// 【Why】为什么需要DryRun：GET请求也需要测试连接，验证参数有效性，确保API可用
	// 【What】DryRun做什么：模拟API调用，测试连接状态，验证参数格式，不执行实际业务
	// 【How】如何使用DryRun：前端自动提供DryRun按钮，点击后触发OnDryRun回调
	// 【触发时机】用户点击DryRun按钮时自动触发，无需用户输入DryRun参数
	// 【返回要求】必须返回Valid状态和测试案例，框架自动展示测试结果
	OnDryRun: func(ctx *runner.Context, req *usercall.OnDryRunReq) (*usercall.OnDryRunResp, error) {
		// 【框架规范】配置获取：从上下文获取配置信息
		config := ctx.GetConfig().(WorkspaceAdminManageAPIConfig)

		// 【业务逻辑】Token验证：检查配置是否有效
		if err := validateToken(config); err != nil {
			return &usercall.OnDryRunResp{
				Valid:   false,
				Message: err.Error(),
			}, nil
		}

		// 【框架规范】参数解码：从请求中解码用户输入参数
		var listReq WorkspaceAdminManageListReq
		if err := req.DecodeBody(&listReq); err != nil {
			return &usercall.OnDryRunResp{
				Valid:   false,
				Message: fmt.Sprintf("参数解码失败: %v", err),
			}, nil
		}

		// 【业务逻辑】参数验证：检查业务参数是否有效
		if listReq.PageSize < 1 || listReq.PageSize > 1000 {
			return &usercall.OnDryRunResp{
				Valid:   false,
				Message: "每页数量必须在1-1000之间",
			}, nil
		}

		// 【业务逻辑】构建API URL：根据参数构建完整的请求URL
		apiURL := fmt.Sprintf("%s?page_size=%d", config.BaseURL, listReq.PageSize)

		// 【框架规范】httpx DryRun：使用httpx库构建测试案例
		// 【Why】为什么用httpx：httpx提供ConnectivityCheck()和DryRun()方法，自动测试连接
		// 【What】httpx DryRun做什么：模拟HTTP请求，测试网络连接，验证请求格式
		// 【How】如何使用：链式调用Get().Header().ConnectivityCheck().DryRun()
		// 【ConnectivityCheck底层实现】通过HEAD方法测试接口可用性和网络连通性
		// 【环境痛点解决】即使代码正确，环境问题（网络、防火墙、DNS等）也会导致API调用失败
		// 【用户价值】让用户提前发现环境问题，避免实际执行时的失败，提供保险机制
		dryRunCase := httpx.Get(apiURL).
			Header("Content-Type", "application/json").
			Header("Token", config.Token).
			Timeout(time.Duration(config.TimeoutSeconds) * time.Second).
			ConnectivityCheck().
			DryRun()

		// 【框架规范】DryRun响应：返回测试结果和案例
		return &usercall.OnDryRunResp{
			Valid:   true,
			Message: fmt.Sprintf("预览获取工作空间列表：每页 %d 个", listReq.PageSize),
			Cases:   []usercall.DryRunCase{dryRunCase},
		}, nil
	},
}

// ==================== 路由注册 ====================

func init() {
	// 工作空间管理操作
	runner.Post(RouterGroup+"/workspace_admin_manage_create", WorkspaceAdminManageCreate, WorkspaceAdminManageCreateOption)
	runner.Post(RouterGroup+"/workspace_admin_manage_list", WorkspaceAdminManageList, WorkspaceAdminManageListOption)
}

//<总结>
//这里是个S2级别的工作空间管理系统，包含工作空间创建、列表查询、配置管理等功能
//技术栈：AutoUpdateConfig配置管理、DryRun回调测试、httpx外部API调用、数据转换
//复杂度：S2级别，包含基础回调机制，简单的业务逻辑处理，完全独立无依赖
//设计模式：使用AutoUpdateConfig管理API配置，支持实时配置更新，符合框架最佳实践
//重要提醒：DryRun回调独立于正常处理逻辑，用于测试验证，前端自动提供DryRun按钮
//外部API：使用httpx库调用远程API，支持Token认证、超时设置和连通性检查
//功能说明：支持工作空间创建、列表查询、API配置管理、连接测试等完整工作空间管理功能
//</总结>


```

### 示例5：复杂Table+Form系统 - 采购管理系统

**功能**：完整的采购业务流程，包含供应商管理、商品管理、采购记录

```go
//retail_purchase.go

/*
<metadata>
<用户需求>
我需要一个采购管理系统，帮助采购员管理供应商、商品和采购记录。

功能需求：

供应商管理：
- 供应商信息：名称、联系方式、地址、状态
- 供应商状态：正常合作、暂停合作、终止合作

商品管理：
- 商品信息：名称、分类、规格、单位、标准单价
- 商品分类：原材料、半成品、成品、包装物
- 商品状态：正常采购、暂停采购、淘汰
- 商品归属：每个商品属于特定供应商

采购管理：
- 采购申请：选择供应商、多选该供应商的商品、填写数量
- 采购记录：记录采购历史、状态跟踪
- 统计分析：采购金额、商品种类、供应商分析

业务规则：
- 采购数量必须大于0
- 系统自动计算总价（数量 × 标准单价）
- 采购状态：待审核、已审核、已完成、已取消
</用户需求>


<文件>retail_purchase.go</文件>

</metadata>
*/


package retail

import (
	"errors"
	"fmt"

	"github.com/yunhanshu-net/function-go/pkg/dto/response"
	"github.com/yunhanshu-net/function-go/pkg/dto/usercall"
	"github.com/yunhanshu-net/function-go/runner"
	"github.com/yunhanshu-net/pkg/query"
	"gorm.io/gorm"
)

// ================ 函数组配置 ================

var RetailPurchaseGroup = &runner.FunctionGroup{
	CnName: "采购管理",
	EnName: "retail_purchase",
}

// ================ 数据模型（按依赖关系排序） ================
// 【框架规范】关联关系挂载Model规则：
// 1. 每个有外键的表都必须挂载对应的Model结构体
// 2. 命名规范：关联字段名 = 关联表结构体名（如：Supplier RetailPurchaseSupplier）
// 3. 标签规范：json:"-" runner:"-" gorm:"foreignKey:字段名"
// 4. 使用场景：Preload("关联字段名")、JOIN查询、关联字段填充
// 5. 好处：避免N+1查询、支持关联搜索、提升查询性能

// 1. 供应商信息（基础数据，被其他表依赖）
type RetailPurchaseSupplier struct {
	ID        int            `json:"id" gorm:"primaryKey;autoIncrement" runner:"name:供应商ID" permission:"read"`
	CreatedAt int64          `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" widget:"type:datetime;kind:datetime" permission:"read"`
	UpdatedAt int64          `json:"updated_at" gorm:"autoUpdateTime:milli" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read"`
	DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index" runner:"-"`

	Name    string `json:"name" gorm:"column:name;comment:供应商名称" runner:"name:供应商名称" widget:"type:input" search:"like" validate:"required,min=2,max=100" msg:"供应商名称必填，长度2-100字符"`
	Contact string `json:"contact" gorm:"column:contact;comment:联系人" runner:"name:联系人" widget:"type:input" search:"like" validate:"required,min=2,max=50" msg:"联系人必填，长度2-50字符"`
	Phone   string `json:"phone" gorm:"column:phone;comment:联系电话" runner:"name:联系电话" widget:"type:input" search:"like" validate:"required,min=11,max=20" msg:"联系电话必填，长度11-20字符"`
	Address string `json:"address" gorm:"column:address;comment:地址" runner:"name:地址" widget:"type:input;mode:text_area" search:"like" validate:"required,min=5,max=200" msg:"地址必填，长度5-200字符"`
}

func (RetailPurchaseSupplier) TableName() string { return "retail_purchase_supplier" }

// 2. 商品信息（依赖供应商，被采购记录依赖）
type RetailPurchaseProduct struct {
	ID        int            `json:"id" gorm:"primaryKey;autoIncrement" runner:"name:商品ID" permission:"read"`
	CreatedAt int64          `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" widget:"type:datetime;kind:datetime" permission:"read"`
	UpdatedAt int64          `json:"updated_at" gorm:"autoUpdateTime:milli" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read"`
	DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index" runner:"-"`

	// 【框架说明】SupplierID必须使用select组件才能支持OnInputFuzzy模糊搜索功能
	// 只有select（单选）和multiselect（多选）组件才支持动态数据源模糊搜索
	// number组件不支持模糊搜索，用户无法通过名称搜索供应商
	SupplierID int `json:"supplier_id" gorm:"column:supplier_id;comment:供应商ID" runner:"name:供应商" widget:"type:select" search:"in" validate:"required" msg:"请选择供应商"`

	// 【框架说明】SupplierName在列表展示时自动填充，属于join其他表的字段了，因此这个字段不能加search标签，注意，注意，注意：gorm:"-"的字段不能加search标签
	//  所以此时如果需要支持非表内字段的搜索，需要在请求参数内添加这个字段，参考：RetailPurchaseRecordListReq，在里面扩展字段
	// permission:"read"表示仅在列表显示，新增和编辑时不显示
	SupplierName string  `json:"supplier_name" gorm:"-" runner:"name:供应商名称" widget:"type:input" permission:"read"` // 【虚拟字段】通过预加载填充，不存储到数据库
	Name         string  `json:"name" gorm:"column:name;comment:商品名称" runner:"name:商品名称" widget:"type:input" search:"like" validate:"required,min=2,max=100" msg:"商品名称必填，长度2-100字符"`
	Category     string  `json:"category" gorm:"column:category;comment:商品分类" runner:"name:商品分类" widget:"type:select;options:原材料,半成品,成品,包装物" data:"default_value:原材料" search:"in" validate:"required,oneof=原材料 半成品 成品 包装物" msg:"请选择商品分类"`
	Spec         string  `json:"spec" gorm:"column:spec;comment:规格" runner:"name:规格" widget:"type:input" search:"like" validate:"required,min=2,max=100" msg:"规格必填，长度2-100字符" data:"example:500g;100ml;A4尺寸;M码;红色"`
	Unit         string  `json:"unit" gorm:"column:unit;comment:单位" runner:"name:单位" widget:"type:input" search:"like" validate:"required,min=1,max=20" msg:"单位必填，长度1-20字符" data:"example:个;件;包;盒;米;千克;升"`
	UnitPrice    float64 `json:"unit_price" gorm:"column:unit_price;comment:标准单价" runner:"name:标准单价" widget:"type:number;min:0;precision:2" search:"gte,lte" validate:"required,min=0" msg:"标准单价必须大于0"`

	// 【框架规范】关联关系挂载Model，支持预加载和关联查询
	// 命名规范：关联字段名 = 关联表结构体名
	// 使用场景：Preload("Supplier")、JOIN查询、关联字段填充
	// 注意事项：json:"-" 隐藏字段，runner:"-" 不渲染，gorm:"foreignKey:SupplierID" 指定外键
	Supplier RetailPurchaseSupplier `json:"-" runner:"-" gorm:"foreignKey:SupplierID"`
}

func (RetailPurchaseProduct) TableName() string { return "retail_purchase_product" }

// 3. 采购商品项（业务数据，依赖商品信息）
type RetailPurchaseItem struct {
	ProductID int `json:"product_id" runner:"name:商品" widget:"type:select" validate:"required" msg:"请选择商品"`
	Quantity  int `json:"quantity" runner:"name:数量" widget:"type:number;min:1" data:"default_value:1" validate:"required,min=1" msg:"数量必须大于0"`
}

// 5. 采购请求（业务操作，依赖上述所有模型）
type RetailPurchaseReq struct {
	SupplierID int                  `json:"supplier_id" runner:"name:供应商" widget:"type:select" validate:"required" msg:"请选择供应商"`
	Items      []RetailPurchaseItem `json:"items" runner:"name:采购商品" widget:"type:list" validate:"required,min=1" msg:"请至少选择一件商品"`
	Remarks    string               `json:"remarks" runner:"name:备注" widget:"type:input;mode:text_area"`
}

// 4. 采购记录（业务数据，依赖供应商和商品）
type RetailPurchaseRecord struct {
	ID        int            `json:"id" gorm:"primaryKey;autoIncrement" runner:"name:采购ID" permission:"read"`
	CreatedAt int64          `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" widget:"type:datetime;kind:datetime" permission:"read"`
	UpdatedAt int64          `json:"updated_at" gorm:"autoUpdateTime:milli" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read"`
	DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index" runner:"-"`

	// 【框架说明】SupplierID在记录表中使用number组件，因为这是历史数据展示，不需要联想功能
	// 联想功能只在新增/编辑时使用，记录表主要用于查询和展示
	// 【框架说明】SupplierID在记录表中使用select组件，支持联想功能
	// 新增和编辑时可以选择供应商，列表展示时隐藏ID字段
	SupplierID int `json:"supplier_id" gorm:"column:supplier_id;comment:供应商ID" runner:"name:供应商" widget:"type:select" search:"in" validate:"required" msg:"请选择供应商" permission:"create,update"`
	// 【框架说明】SupplierName在列表展示时自动填充，属于join其他表的字段了，因此这个字段不能加search标签，注意，注意，注意：gorm:"-"的字段不能加search标签
	//  所以此时如果需要支持非表内字段的搜索，需要在请求参数内添加这个字段，参考：RetailPurchaseRecordListReq，在里面扩展字段
	// permission:"read"表示仅在列表显示，新增和编辑时不显示
	SupplierName string  `json:"supplier_name" gorm:"-" runner:"name:供应商名称" widget:"type:input"  validate:"required" msg:"供应商名称必填" permission:"read"`
	TotalAmount  float64 `json:"total_amount" gorm:"column:total_amount;comment:总金额" runner:"name:总金额" widget:"type:number;precision:2" search:"gte,lte" validate:"required,min=0" msg:"总金额必须大于0"`
	TotalItems   int     `json:"total_items" gorm:"column:total_items;comment:商品种类" runner:"name:商品种类" widget:"type:number" search:"gte,lte" validate:"required,min=1" msg:"商品种类必须大于0"`
	Status       string  `json:"status" gorm:"column:status;comment:状态" runner:"name:状态" widget:"type:select;options:待审核,已审核,已完成,已取消" data:"default_value:待审核" search:"in" validate:"required,oneof=待审核 已审核 已完成 已取消" msg:"请选择采购状态"`
	Remarks      string  `json:"remarks" gorm:"column:remarks;comment:备注" runner:"name:备注" widget:"type:input;mode:text_area" search:"like"`

	// 【框架规范】关联关系挂载Model，支持预加载和关联查询
	// 命名规范：关联字段名 = 关联表结构体名
	// 使用场景：Preload("Supplier")、JOIN查询、关联字段填充
	// 注意事项：json:"-" 隐藏字段，runner:"-" 不渲染，gorm:"foreignKey:SupplierID" 指定外键
	Supplier RetailPurchaseSupplier `json:"-" runner:"-" gorm:"foreignKey:SupplierID"`
}

func (RetailPurchaseRecord) TableName() string { return "retail_purchase_record" }

// 6. 采购响应（业务结果）
type RetailPurchaseResp struct {
	PurchaseID  int     `json:"purchase_id" runner:"name:采购ID" widget:"type:number"`
	TotalAmount float64 `json:"total_amount" runner:"name:总金额" widget:"type:number;precision:2"`
	TotalItems  int     `json:"total_items" runner:"name:商品种类" widget:"type:number"`
	Message     string  `json:"message" runner:"name:处理结果" widget:"type:input;mode:text_area"`
}

// ================ 业务逻辑函数（按调用顺序排序） ================

// 1. 辅助函数：验证商品并计算总金额
func retailPurchaseValidateAndCalculate(db *gorm.DB, supplierID int, items []RetailPurchaseItem) (float64, int, error) {
	if len(items) == 0 {
		return 0, 0, fmt.Errorf("采购商品不能为空")
	}

	var totalAmount float64
	productIDs := make([]int, 0, len(items))

	for _, item := range items {
		if item.Quantity <= 0 {
			return 0, 0, fmt.Errorf("商品数量必须大于0")
		}
		productIDs = append(productIDs, item.ProductID)
	}

	// 验证商品是否存在且属于指定供应商
	var products []*RetailPurchaseProduct
	if err := db.Where("id IN ? AND supplier_id = ?", productIDs, supplierID).Find(&products).Error; err != nil {
		return 0, 0, fmt.Errorf("验证商品失败: %v", err)
	}
	if len(products) != len(productIDs) {
		return 0, 0, fmt.Errorf("部分商品不存在或不属于该供应商")
	}

	// 计算总金额（数量 × 标准单价）
	for _, item := range items {
		for _, product := range products {
			if product.ID == item.ProductID {
				totalAmount += float64(item.Quantity) * product.UnitPrice
				break
			}
		}
	}

	return totalAmount, len(productIDs), nil
}

// 2. 主要业务函数：创建采购申请
func RetailPurchaseCreate(ctx *runner.Context, req *RetailPurchaseReq, resp response.Response) error {
	db := ctx.MustGetOrInitDB()

	// 1. 验证供应商
	var supplier RetailPurchaseSupplier
	if err := db.Where("id = ?", req.SupplierID).First(&supplier).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return resp.Form(&RetailPurchaseResp{
				Message: "供应商不存在",
			}).Build()
		}
		return resp.Form(&RetailPurchaseResp{
			Message: fmt.Sprintf("查询供应商失败: %v", err),
		}).Build()
	}

	// 2. 验证商品并计算
	totalAmount, totalItems, err := retailPurchaseValidateAndCalculate(db, req.SupplierID, req.Items)
	if err != nil {
		return resp.Form(&RetailPurchaseResp{
			Message: fmt.Sprintf("商品验证失败: %v", err),
		}).Build()
	}

	// 3. 创建采购记录
	purchaseRecord := &RetailPurchaseRecord{
		SupplierID:   req.SupplierID,
		SupplierName: supplier.Name,
		TotalAmount:  totalAmount,
		TotalItems:   totalItems,
		Status:       "待审核",
		Remarks:      req.Remarks,
	}

	if err := db.Create(purchaseRecord).Error; err != nil {
		ctx.Logger.Errorf("创建采购记录失败: %v", err)
		return resp.Form(&RetailPurchaseResp{
			Message: "创建采购记录失败，请重试",
		}).Build()
	}

	return resp.Form(&RetailPurchaseResp{
		PurchaseID:  purchaseRecord.ID,
		TotalAmount: totalAmount,
		TotalItems:  totalItems,
		Message:     "采购申请创建成功",
	}).Build()
}

// ================ Table函数（按数据依赖关系排序） ================

// 1. 供应商列表管理（基础数据管理）
func RetailPurchaseSupplierList(ctx *runner.Context, req *query.SearchFilterPageReq, resp response.Response) error {
	db := ctx.MustGetOrInitDB()
	var rows []*RetailPurchaseSupplier
	return resp.Table(&rows).AutoPaginated(db, &RetailPurchaseSupplier{}, req).Build()
}

// 2. 商品列表管理（依赖供应商数据）
func RetailPurchaseProductList(ctx *runner.Context, req *query.SearchFilterPageReq, resp response.Response) error {
	db := ctx.MustGetOrInitDB()
	var rows []*RetailPurchaseProduct

	// 【优化】预加载供应商信息，避免N+1查询问题
	query := db.Model(&RetailPurchaseProduct{}).Preload("Supplier")

	// 获取分页数据（应用手动构建的查询条件）
	td := resp.Table(&rows).AutoPaginated(query, &RetailPurchaseProduct{}, req)

	// 【框架说明】填充虚拟字段，提升用户体验
	// 在列表展示时自动填充供应商名称，避免显示无意义的ID
	for _, row := range rows {
		if row.Supplier.ID > 0 {
			row.SupplierName = row.Supplier.Name
		}
	}

	return td.Build()
}

// 3. 采购记录列表管理（依赖供应商和商品数据）
type RetailPurchaseRecordListReq struct {
	query.SearchFilterPageReq `runner:"-"`

	// 【框架说明】join字段搜索参数
	// query.SearchFilterPageReq 默认只支持当前表字段的搜索（如 TotalAmount、TotalItems、Status）
	// 但无法处理关联表的字段搜索（如供应商名称），需要手动实现关联查询
	SupplierName string `json:"supplier_name" runner:"name:供应商名称" widget:"type:input" search:"like"` // 按供应商名称模糊搜索
}

func RetailPurchaseRecordList(ctx *runner.Context, req *RetailPurchaseRecordListReq, resp response.Response) error {
	db := ctx.MustGetOrInitDB()
	var rows []*RetailPurchaseRecord

	// 【框架说明】手动实现join字段的搜索逻辑
	// 因为框架的 AutoPaginated 无法自动处理关联表字段的搜索
	// 需要手动构建查询条件，实现类似 JOIN 的效果
	query := db.Model(&RetailPurchaseRecord{})

	// 按供应商名称模糊搜索（需要关联查询）
	if req.SupplierName != "" {
		// 先查询匹配的供应商ID
		var supplierIDs []int
		if err := db.Model(&RetailPurchaseSupplier{}).
			Where("name LIKE ?", "%"+req.SupplierName+"%").
			Pluck("id", &supplierIDs).Error; err == nil && len(supplierIDs) > 0 {
			query = query.Where("supplier_id IN ?", supplierIDs)
		} else {
			// 如果没有找到匹配的供应商，返回空结果
			return resp.Table(nil).Build()
		}
	}
	// 【优化】预加载供应商信息，避免N+1查询问题
	query = query.Preload("Supplier")
	// 获取分页数据（应用手动构建的查询条件）
	td := resp.Table(&rows).AutoPaginated(query, &RetailPurchaseRecord{}, &req.SearchFilterPageReq)

	// 【框架说明】填充join字段，提升用户体验
	// 在列表展示时自动填充供应商名称，避免显示无意义的ID
	for _, row := range rows {
		row.SupplierName = row.Supplier.Name
	}

	return td.Build()
}

// ================ 函数配置（按功能层次排序） ================

// 1. 供应商列表配置（基础数据管理）
var RetailPurchaseSupplierListOption = &runner.TableFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "采购供应商管理",
		ApiDesc:      "供应商基础信息管理，支持增删改查和搜索",
		Tags:         []string{"采购管理", "供应商管理"},
		Request:      &query.SearchFilterPageReq{},
		Response:     query.PaginatedTable[[]*RetailPurchaseSupplier]{},
		CreateTables: []interface{}{&RetailPurchaseSupplier{}},
		Group:        RetailPurchaseGroup,
	},
	AutoCrudTable: &RetailPurchaseSupplier{},

	// 【框架说明】OnTableAddRows 在新增供应商后触发，用于额外的业务逻辑处理
	// 触发时机：用户新增供应商成功后    使用场景：记录日志、发送通知、更新缓存等
	// ⚠️ 重要：有此回调时框架不会自动写入数据，必须在回调中手动执行 db.Create()
	OnTableAddRows: func(ctx *runner.Context, req *usercall.OnTableAddRowsReq) (*usercall.OnTableAddRowsResp, error) {
		// 【业务场景】新增供应商后，记录操作日志
		// 这里演示了如何在基础CRUD之外添加额外的业务操作

		// 解析新增的供应商数据
		var suppliers []*RetailPurchaseSupplier
		if err := req.DecodeBy(&suppliers); err != nil {
			return nil, fmt.Errorf("解析供应商数据失败: %v", err)
		}
		//然后可以在写入前后做任何操作，但是不要太复杂，要不然会影响用户体验

		// 【关键步骤】手动执行数据库写入操作（用了OnTableAddRows框架不会自动执行写入）
		db := ctx.MustGetOrInitDB()
		err := db.Create(&suppliers).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableAddRowsResp{}, nil
	},

	// 【框架说明】OnTableUpdateRows 在更新供应商后触发，用于额外的业务逻辑处理
	// 触发时机：用户更新供应商成功后    使用场景：数据同步、状态检查、关联更新等
	// ⚠️ 重要：有此回调时框架不会自动更新数据，必须在回调中手动执行 db.Model().Updates()
	OnTableUpdateRows: func(ctx *runner.Context, req *usercall.OnTableUpdateRowsReq) (*usercall.OnTableUpdateRowsResp, error) {
		// 【业务场景】更新供应商后，记录变更历史
		// 这里演示了如何在数据更新后处理关联业务逻辑

		// 【关键步骤】手动执行数据库更新操作（框架不会自动执行）
		db := ctx.MustGetOrInitDB()

		var updateValue RetailPurchaseSupplier
		err := req.DecodeBy(&updateValue) //【框架规范】注意这里只会获取到更新的字段的值，例如更新phone的话updateValue的Phone字段会被赋值
		if err != nil {
			return nil, err
		}

		//GetString，GetInt，GetBool，GetFloat64，GetFiles 这几个方法，可以安全的获取更新字段的值，下面几个只是演示一下用法，正常情况下字段校验的逻辑会被框架和前端处理，
		//name, exist, err := req.GetString("name")
		//if err != nil {
		//	return nil, err
		//}
		//if exist {
		//	if name == "" {
		//		return nil, fmt.Errorf("名称不能为空")
		//	}
		//}

		//phone, exist, err := req.GetInt("phone")
		//if err != nil {
		//	return nil, err
		//}
		//fmt.Println(phone)

		//GetFieldsMap() 返回 map[string]interface 是需要更新的字段和更新的值
		//fieldsMap := req.GetFieldsMap()
		err = db.Where("id in ?", req.GetIds()).Updates(updateValue).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableUpdateRowsResp{}, nil
	},

	// 【框架说明】OnTableDeleteRows 在删除供应商前触发，用于业务规则验证
	// 触发时机：用户删除供应商前    使用场景：关联检查、防止误删
	// ⚠️ 重要：有此回调时框架不会自动删除数据，必须在回调中手动执行 db.Delete()
	OnTableDeleteRows: func(ctx *runner.Context, req *usercall.OnTableDeleteRowsReq) (*usercall.OnTableDeleteRowsResp, error) {
		// 【业务场景】删除供应商前，检查是否有关联商品，防止误删
		db := ctx.MustGetOrInitDB()

		// 检查是否有关联商品
		for _, id := range req.GetIds() {
			var count int64
			if err := db.Model(&RetailPurchaseProduct{}).Where("supplier_id = ?", id).Count(&count).Error; err != nil {
				return nil, fmt.Errorf("检查供应商关联商品失败: %v", err)
			}

			if count > 0 {
				var supplier RetailPurchaseSupplier
				if err := db.Where("id = ?", id).First(&supplier).Error; err != nil {
					return nil, fmt.Errorf("查询供应商信息失败: %v", err)
				}
				return nil, fmt.Errorf("供应商 %s 下还有 %d 个商品，无法删除，请先把相关商品删除", supplier.Name, count)
			}
		}

		// 手动执行删除操作
		if err := db.Where("id IN ?", req.GetIds()).Delete(&RetailPurchaseSupplier{}).Error; err != nil {
			return nil, fmt.Errorf("删除供应商记录失败: %v", err)
		}

		return &usercall.OnTableDeleteRowsResp{}, nil
	},
}

// 2. 商品列表配置（依赖供应商数据）
var RetailPurchaseProductListOption = &runner.TableFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "采购商品管理",
		ApiDesc:      "商品基础信息管理，支持增删改查和搜索",
		Tags:         []string{"采购管理", "商品管理"},
		Request:      &query.SearchFilterPageReq{},
		Response:     query.PaginatedTable[[]*RetailPurchaseProduct]{},
		CreateTables: []interface{}{&RetailPurchaseProduct{}},
		Group:        RetailPurchaseGroup,
	},
	AutoCrudTable: &RetailPurchaseProduct{},

	// 【框架说明】OnInputFuzzyMap 为表格字段提供模糊搜索数据
	// 触发时机：用户输入时    数据去向：挂载到对应的表格字段
	//OnInputFuzzyMap的每一个都可以被其他的options复用
	OnInputFuzzyMap: map[string]runner.OnInputFuzzy{
		"supplier_id": func(ctx *runner.Context, req *usercall.OnInputFuzzyReq) (*usercall.OnInputFuzzyResp, error) {
			// 【当前场景】supplier_id是单选字段，只返回静态信息，不做聚合计算
			// 【目标字段】为 RetailPurchaseProduct.SupplierID 提供供应商选择数据
			var suppliers []*RetailPurchaseSupplier
			db := ctx.MustGetOrInitDB()

			if req.IsByFiledValues() {
				// 多值查询：使用 IN 查询，这里必须用 db = db.Where
				db = db.Where("id in ?", req.GetFiledValues())
			} else if req.IsByFiledValue() {
				// 单值查询：使用等值查询，性能最优
				db = db.Where("id = ?", req.GetFiledValue()).Limit(1)
			} else {
				// 模糊查询：关键字搜索
				db = db.Where("name LIKE ? OR contact LIKE ? OR phone LIKE ?", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%").
					Limit(20)
			}
			db.Find(&suppliers)

			items := make([]*usercall.InputFuzzyItem, 0)
			for _, s := range suppliers {
				items = append(items, &usercall.InputFuzzyItem{
					Value: s.ID,
					Label: s.Name,
					DisplayInfo: map[string]interface{}{
						"供应商名称": s.Name,
						"联系人":   s.Contact,
						"联系电话":  s.Phone,
						"地址":    s.Address,
					},
				})
			}

			return &usercall.OnInputFuzzyResp{
				Statistics: map[string]interface{}{
					"供应商名称": "text(供应商名称)", //前端动态展示选中的那个供应商名称
					"联系人":   "text(联系人)",   //前端动态展示选中的那个供应商联系人
					"联系电话":  "text(联系电话)",  //前端动态展示选中的那个供应商联系电话
					"地址":    "text(地址)",    //前端动态展示选中的那个供应商地址
				},
				Values: items,
			}, nil
		},
	},
}

// 3. 采购记录列表配置（依赖供应商和商品数据）
var RetailPurchaseRecordListOption = &runner.TableFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "采购记录管理",
		ApiDesc:      "采购记录管理，支持状态跟踪、供应商筛选和统计分析",
		Tags:         []string{"采购管理", "记录管理"},
		Request:      &RetailPurchaseRecordListReq{},
		Response:     query.PaginatedTable[[]*RetailPurchaseRecord]{},
		CreateTables: []interface{}{&RetailPurchaseRecord{}},
		Group:        RetailPurchaseGroup,
	},
	AutoCrudTable: &RetailPurchaseRecord{},

	// 【框架说明】复用采购创建的OnInputFuzzy配置，避免重复造轮子
	// 供应商联想功能在新增和编辑时都需要，直接复用已有配置
	OnInputFuzzyMap: map[string]runner.OnInputFuzzy{
		"supplier_id": RetailPurchaseProductListOption.OnInputFuzzyMap["supplier_id"], //可以复用RetailPurchaseProductListOption 的supplier_id 的OnInputFuzzyMap
	},
}

// 4. 采购创建配置（核心业务逻辑）
var RetailPurchaseCreateOption = &runner.FormFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "采购申请创建",
		ApiDesc:      "创建采购申请，支持多商品选择和实时统计",
		Tags:         []string{"采购管理", "申请创建"},
		Request:      &RetailPurchaseReq{},
		Response:     &RetailPurchaseResp{},
		CreateTables: []interface{}{&RetailPurchaseRecord{}},
		Group:        RetailPurchaseGroup,
	},

	// 【框架说明】OnInputFuzzyMap 为请求结构体字段提供模糊搜索数据
	// 触发时机：用户输入时    数据去向：挂载到对应的请求字段
	OnInputFuzzyMap: map[string]runner.OnInputFuzzy{
		"supplier_id": RetailPurchaseProductListOption.OnInputFuzzyMap["supplier_id"], //这里为了防止重复造轮子，可以直接复用RetailPurchaseProductListOption已经存在的方法

		"product_id": func(ctx *runner.Context, req *usercall.OnInputFuzzyReq) (*usercall.OnInputFuzzyResp, error) {
			// 【当前场景】product_id是list内单选字段，支持聚合统计计算
			// 【目标字段】为 RetailPurchaseItem.ProductID 提供商品选择数据
			// 注意：这里需要根据已选择的供应商来过滤商品

			// 【框架说明】通过req.DecodeBy获取表单上下文中的supplier_id
			// 这样可以确保商品选择与供应商选择保持一致性
			var currentInputData RetailPurchaseReq
			if err := req.DecodeBy(&currentInputData); err != nil {
				return nil, fmt.Errorf("表单解析失败，请刷新选择供应商后再重试")
			}

			if currentInputData.SupplierID == 0 {
				return nil, fmt.Errorf("请先选择供应商，再选择商品")
			}

			var products []*RetailPurchaseProduct
			db := ctx.MustGetOrInitDB()

			if req.IsByFiledValues() {
				// 多值查询：使用 IN 查询，这里必须用 db = db.Where
				db = db.Where("id in ?", req.GetFiledValues())
			} else if req.IsByFiledValue() {
				// 单值查询：使用等值查询，性能最优
				db = db.Where("id = ?", req.GetFiledValue()).Limit(1)
			} else {
				// 模糊查询：关键字搜索
				db = db.Where("name LIKE ? OR spec LIKE ? OR category LIKE ?", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%").
					Limit(20)
			}
			// 根据供应商ID过滤商品，确保只能选择该供应商的商品
			db.Where("supplier_id = ?", currentInputData.SupplierID).Find(&products)

			items := make([]*usercall.InputFuzzyItem, 0)
			for _, p := range products {
				items = append(items, &usercall.InputFuzzyItem{
					Value: p.ID,
					Label: fmt.Sprintf("%s - %s (¥%.2f/%s)", p.Name, p.Spec, p.UnitPrice, p.Unit),
					DisplayInfo: map[string]interface{}{
						"商品名称": p.Name,
						"规格":   p.Spec,
						"分类":   p.Category,
						"单位":   p.Unit,
						"标准单价": p.UnitPrice,
					},
				})
			}

			return &usercall.OnInputFuzzyResp{
				Statistics: map[string]interface{}{
					// ✅ 前端实时聚合计算 - 用户每添加一行商品，前端立即计算
					"采购总金额": "sum(标准单价,*quantity)", // 用户选择的所有商品总价
					"九折金额":  "sum(标准单价,*0.9)",      // 用户选择的所有商品总价*0.9
					"商品种类数": "count(标准单价)",         // 选了几种商品
					"采购总数量": "sum(quantity)",       // 商品总数量
					"平均单价":  "avg(标准单价)",           // 选中商品平均价格

					// ✅ 有用的静态信息
					"采购说明": "批量采购享优惠",
					"付款方式": "月结30天",
				},
				Values: items,
			}, nil
		},
	},
}

// ================ API注册（按功能层次排序） ================

func init() {
	// 1. Table函数 - 基础数据管理（按依赖关系排序）
	//RouterGroup 变量可以直接用，当前package下已经创建好该变量了
	runner.Get(RouterGroup+"/retail_purchase_supplier_list", RetailPurchaseSupplierList, RetailPurchaseSupplierListOption)
	runner.Get(RouterGroup+"/retail_purchase_product_list", RetailPurchaseProductList, RetailPurchaseProductListOption)
	runner.Get(RouterGroup+"/retail_purchase_record_list", RetailPurchaseRecordList, RetailPurchaseRecordListOption)

	// 2. Form函数 - 业务逻辑处理（依赖基础数据）
	runner.Post(RouterGroup+"/retail_purchase_create", RetailPurchaseCreate, RetailPurchaseCreateOption)
}
//<总结>
//采购管理系统：供应商管理、商品管理、采购记录管理
//技术栈：AutoCrudTable自动生成CRUD界面、OnInputFuzzy模糊搜索、Statistics前端选中实时聚合计算、OnTable表格回调机制、GORM预加载优化
//复杂度：S2级别，包含回调机制和业务逻辑处理，无复杂依赖关系
//业务逻辑：商品属于供应商，采购时支持多商品选择，系统自动计算总价和统计信息
//性能优化：GORM预加载避免N+1查询，JOIN查询优化关联搜索
//</总结>

```

table函数最佳实践：招聘管理系统
用户需求：
需要一个招聘管理系统，用户可以发起简历投递，简历用附件的形式上传，然后填写自己的个人信息，然后管理员可以进行简历的增删改查，每个简历都应该有自己的状态，待面试，已面试，已通过，已落选，然后可以投递的职位分为，前端开发岗位，后端开发岗，运营岗，运维岗，美术岗，设计岗，产品岗
另外可以选择的工作地有：北京，上海，深圳，广州，南京，武汉，成都，重庆，杭州 这些
同时用户可以选择自己的标签：默认可选项（开源项目,AI编程,全栈开发,经验丰富,应届生,懂运维,数据分析）允许自定义多选值

```go
// 文件名：hr_recruitment.go
package hr

import (
	"fmt"

	"github.com/yunhanshu-net/function-go/pkg/dto/response"
	"github.com/yunhanshu-net/function-go/pkg/dto/usercall"
	"github.com/yunhanshu-net/function-go/runner"
	"github.com/yunhanshu-net/pkg/query"
	"github.com/yunhanshu-net/pkg/typex/files"
	"gorm.io/gorm"
)

// 招聘管理系统函数组
var HrRecruitmentGroup = &runner.FunctionGroup{
	CnName: "招聘管理系统",
	EnName: "hr_recruitment",
}

// 简历数据模型
type HrRecruitment struct {
	// 框架标签：runner:"name:简历ID" - 设置字段在前端的显示名称
	// 框架标签：permission:"read" - 字段只读权限（不能编辑）
	// 框架标签：search:"eq,gte,lte" - 启用精确搜索和范围搜索功能
	// 注意：gorm:"column:id" 明确指定数据库列名，确保映射正确
	ID int `json:"id" gorm:"primaryKey;autoIncrement;column:id" runner:"name:简历ID" permission:"read" search:"eq,gte,lte"`

	// 框架标签：widget:"type:datetime;kind:datetime" - 日期时间选择器组件
	// 框架标签：search:"gte,lte" - 启用时间范围搜索功能（大于等于、小于等于）
	// 注意：gorm:"autoCreateTime:milli" 自动填充创建时间（毫秒级时间戳，必须是毫秒级别）
	CreatedAt int64 `json:"created_at" gorm:"autoCreateTime:milli;column:created_at" runner:"name:投递时间" widget:"type:datetime;kind:datetime" permission:"read" search:"gte,lte"`

	// 框架标签：widget:"type:datetime;kind:datetime" - 日期时间选择器组件
	// 框架标签：search:"gte,lte" - 启用时间范围搜索功能（大于等于、小于等于）
	// 注意：gorm:"autoUpdateTime:milli" 自动填充更新时间（毫秒级时间戳，必须是毫秒级别）
	UpdatedAt int64 `json:"updated_at" gorm:"autoUpdateTime:milli;column:updated_at" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read" search:"gte,lte"`

	// 框架标签：runner:"-" - 隐藏字段（不在前端显示）
	DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index;column:deleted_at" runner:"-"`

	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required,min=2,max=20" - 必填字段，长度2-20字符
	Name string `json:"name" gorm:"column:name" runner:"name:姓名" widget:"type:input" search:"like" validate:"required,min=2,max=20"`

	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required,min=11,max=11" - 必填字段，长度必须为11位
	Phone string `json:"phone" gorm:"column:phone" runner:"name:手机号" widget:"type:input" search:"like" validate:"required,min=11,max=11"`

	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required,email" - 必填字段，必须是有效的邮箱格式
	Email string `json:"email" gorm:"column:email" runner:"name:邮箱" widget:"type:input" search:"like" validate:"required,email"`

	// 框架标签：widget:"type:number;min:18;max:65;unit:岁" - 数字输入组件，最小值18，最大值65，单位岁
	// 框架标签：search:"gte,lte" - 启用范围搜索功能（大于等于、小于等于）
	// 框架标签：validate:"required,min=18,max=65" - 必填字段，年龄范围18-65岁
	Age int `json:"age" gorm:"column:age" runner:"name:年龄" widget:"type:number;min:18;max:65;unit:岁" search:"gte,lte" validate:"required,min=18,max=65"`

	// 框架标签：widget:"type:select;options:男,女" - 下拉选择组件（选项：男/女）
	// 框架标签：search:"in" - 启用精确匹配搜索功能
	// 框架标签：validate:"required,oneof=男 女" - 必填字段，值必须是选项之一
	Gender string `json:"gender" gorm:"column:gender" runner:"name:性别" widget:"type:select;options:男,女" search:"in" validate:"required,oneof=男 女"`

	// 框架标签：widget:"type:select;options:高中,大专,本科,硕士,博士" - 下拉选择组件
	// 框架标签：search:"in" - 启用精确匹配搜索功能
	// 框架标签：validate:"required" - 必填字段
	Education string `json:"education" gorm:"column:education" runner:"name:学历" widget:"type:select;options:高中,大专,本科,硕士,博士" search:"in" validate:"required"`

	// 框架标签：widget:"type:select;options:前端开发岗,后端开发岗,运营岗,运维岗,美术岗,设计岗,产品岗" - 下拉选择组件
	// 框架标签：search:"in" - 启用精确匹配搜索功能
	// 框架标签：validate:"required" - 必填字段
	Position string `json:"position" gorm:"column:position" runner:"name:应聘职位" widget:"type:select;options:前端开发岗,后端开发岗,运营岗,运维岗,美术岗,设计岗,产品岗" search:"in" validate:"required"`

	// 框架标签：widget:"type:select;options:北京,上海,深圳,广州,南京,武汉,成都,重庆,杭州" - 下拉选择组件
	// 框架标签：search:"in" - 启用精确匹配搜索功能
	// 框架标签：validate:"required" - 必填字段
	WorkCity string `json:"work_city" gorm:"column:work_city" runner:"name:期望工作地" widget:"type:select;options:北京,上海,深圳,广州,南京,武汉,成都,重庆,杭州" search:"in" validate:"required"`

	// 框架标签：widget:"type:select;options:应届生,1年以下,1-3年,3-5年,5-10年,10年以上" - 下拉选择组件
	// 框架标签：search:"in" - 启用精确匹配搜索功能
	// 框架标签：validate:"required" - 必填字段
	Experience string `json:"experience" gorm:"column:experience" runner:"name:工作经验" widget:"type:select;options:应届生,1年以下,1-3年,3-5年,5-10年,10年以上" search:"in" validate:"required"`

	// 条件字段：当工作经验=应届生时显示毕业时间字段
	// 框架标签：widget:"type:number;min:2020;max:2030;unit:年" - 数字输入组件，最小值2020，最大值2030，单位年
	// 框架标签：search:"gte,lte" - 启用范围搜索功能（大于等于、小于等于）
	// 框架标签：validate:"required_if=experience 应届生,min=2020,max=2030" - 当工作经验=应届生时必填
	GraduationYear int `json:"graduation_year" gorm:"column:graduation_year;comment:毕业年份" runner:"name:毕业年份" widget:"type:number;min:2020;max:2030;unit:年" search:"gte,lte" data:"default_value:2024;example:2024" validate:"required_if=experience 应届生,min=2020,max=2030"`

	// 条件字段：当工作经验=应届生时显示实习经历
	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required_if=experience 应届生" - 当工作经验=应届生时必填
	InternshipExperience string `json:"internship_experience" gorm:"column:internship_experience;comment:实习经历" runner:"name:实习经历" widget:"type:input;mode:text_area" search:"like" data:"example:在XX公司实习3个月，负责前端开发" validate:"required_if=experience 应届生"`

	// 条件字段：当工作经验≠应届生时显示项目经验
	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required_unless=experience 应届生" - 当工作经验≠应届生时必填
	ProjectExperience string `json:"project_experience" gorm:"column:project_experience;comment:项目经验" runner:"name:项目经验" widget:"type:input;mode:text_area" search:"like" data:"example:负责XX项目的架构设计和开发" validate:"required_unless=experience 应届生"`

	// 框架标签：widget:"type:select;options:5K以下,5K-10K,10K-15K,15K-20K,20K-30K,30K以上" - 下拉选择组件
	// 框架标签：search:"in" - 启用精确匹配搜索功能
	// 框架标签：validate:"required" - 必填字段
	Salary string `json:"salary" gorm:"column:salary" runner:"name:期望薪资" widget:"type:select;options:5K以下,5K-10K,10K-15K,15K-20K,20K-30K,30K以上" search:"in" validate:"required"`

	// 条件字段：当期望薪资=30K以上时显示具体薪资
	// 框架标签：widget:"type:number;min:30000;max:100000;unit:元" - 数字输入组件，最小值30000，最大值100000，单位元
	// 框架标签：search:"gte,lte" - 启用范围搜索功能（大于等于、小于等于）
	// 框架标签：validate:"required_if=salary 30K以上,min=30000,max=100000" - 当期望薪资=30K以上时必填
	SpecificSalary int `json:"specific_salary" gorm:"column:specific_salary;comment:具体期望薪资" runner:"name:具体期望薪资" widget:"type:number;min:30000;max:100000;unit:元" search:"gte,lte" data:"example:35000" validate:"required_if=salary 30K以上,min=30000,max=100000"`

	// 框架标签：widget:"type:file_upload;accept:.pdf,.doc,.docx;max_size:10MB" - 文件上传组件
	// 框架标签：accept:.pdf,.doc,.docx - 允许上传的文件类型
	// 注意：gorm:"type:json" 指定数据库存储为JSON类型
	// 框架标签：validate:"required" - 必填字段
	//search:"-" 不允许搜索
	Resume *files.Files `json:"resume" gorm:"type:json;column:resume" runner:"name:简历附件" widget:"type:file_upload;accept:.pdf,.doc,.docx;max_size:10MB" validate:"required" search:"-"`

	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required,min=20,max=500" - 必填字段，长度20-500字符
	Introduce string `json:"introduce" gorm:"column:introduce" runner:"name:自我介绍" widget:"type:input;mode:text_area" search:"like" validate:"required,min=20,max=500"`

	// 框架标签：widget:"type:multiselect;options:开源项目,AI编程,全栈开发,经验丰富,应届生,懂运维,数据分析;allow_create:true" - 多选组件
	// 框架标签：allow_create:true - 允许创建自定义标签
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 注意：multiselect有两种类型，一种string的会用,号分隔多个值，第二种[]string，会直接用切片存储多个值
	// 为了方便存储到数据库我们选择用string
	Tags string `json:"tags" gorm:"column:tags;comment:个人标签" runner:"name:个人标签" widget:"type:multiselect;options:开源项目,AI编程,全栈开发,经验丰富,应届生,懂运维,数据分析;allow_create:true" search:"like"`

	// 条件字段：当学历=硕士或博士时显示毕业院校
	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required_if=education 博士" - 当学历=博士时必填
	GraduateSchool string `json:"graduate_school" gorm:"column:graduate_school;comment:毕业院校" runner:"name:毕业院校" widget:"type:input" search:"like" data:"example:清华大学" validate:"required_if=education 博士"`

	// 条件字段：当学历=博士时显示研究方向
	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	// 框架标签：validate:"required_if=education 博士" - 当学历=博士时必填
	ResearchField string `json:"research_field" gorm:"column:research_field;comment:研究方向" runner:"name:研究方向" widget:"type:input" search:"like" data:"example:人工智能" validate:"required_if=education 博士"`

	// 框架标签：widget:"type:select;options:待面试,已面试,已通过,已落选" - 下拉选择组件
	// 框架标签：data:"default_value:待面试" - 设置默认状态为"待面试"
	// 框架标签：search:"in" - 启用精确匹配搜索功能
	// 框架标签：validate:"required,oneof=待面试 已面试 已通过 已落选" - 值必须是有效状态
	Status string `json:"status" gorm:"column:status" runner:"name:简历状态" widget:"type:select;options:待面试,已面试,已通过,已落选" data:"default_value:待面试" search:"in" validate:"required,oneof=待面试 已面试 已通过 已落选"`

	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	Remark string `json:"remark" gorm:"column:remark" runner:"name:备注" widget:"type:input;mode:text_area" search:"like"`

	// 框架标签：widget:"type:user" - 用户组件
	// 框架标签：search:"like" - 启用模糊搜索功能
	CreateBy string `json:"create_by" gorm:"column:create_by" runner:"name:投递人" widget:"type:user" search:"like"`
}

// 指定数据库表名
func (HrRecruitment) TableName() string { return "hr_recruitment" }

// 简历投递请求结构
type HrRecruitmentApplyReq struct {
	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：validate:"required,min=2,max=20" - 必填字段，长度2-20字符
	Name string `json:"name" runner:"name:姓名" widget:"type:input" validate:"required,min=2,max=20"`

	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：validate:"required,min=11,max=11" - 必填字段，长度必须为11位
	Phone string `json:"phone" runner:"name:手机号" widget:"type:input" validate:"required,min=11,max=11"`

	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：validate:"required,email" - 必填字段，必须是有效的邮箱格式
	Email string `json:"email" runner:"name:邮箱" widget:"type:input" validate:"required,email"`

	// 框架标签：widget:"type:number;min:18;max:65;unit:岁" - 数字输入组件，最小值18，最大值65，单位岁
	// 框架标签：validate:"required,min=18,max=65" - 必填字段，年龄范围18-65岁
	Age int `json:"age" runner:"name:年龄" widget:"type:number;min:18;max:65;unit:岁" validate:"required,min=18,max=65"`

	// 框架标签：widget:"type:select;options:男,女" - 下拉选择组件（选项：男/女）
	// 框架标签：validate:"required,oneof=男 女" - 必填字段，值必须是选项之一
	Gender string `json:"gender" runner:"name:性别" widget:"type:select;options:男,女" validate:"required,oneof=男 女"`

	// 框架标签：widget:"type:select;options:高中,大专,本科,硕士,博士" - 下拉选择组件
	// 框架标签：validate:"required" - 必填字段
	Education string `json:"education" runner:"name:学历" widget:"type:select;options:高中,大专,本科,硕士,博士" validate:"required"`

	// 条件字段：当学历=硕士或博士时显示毕业院校
	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：validate:"required_if=education 博士" - 当学历=博士时必填
	GraduateSchool string `json:"graduate_school" runner:"name:毕业院校" widget:"type:input" data:"example:清华大学" validate:"required_if=education 博士"`

	// 条件字段：当学历=博士时显示研究方向
	// 框架标签：widget:"type:input" - 文本输入框组件
	// 框架标签：validate:"required_if=education 博士" - 当学历=博士时必填
	ResearchField string `json:"research_field" runner:"name:研究方向" widget:"type:input" data:"example:人工智能" validate:"required_if=education 博士"`

	// 框架标签：widget:"type:select;options:前端开发岗,后端开发岗,运营岗,运维岗,美术岗,设计岗,产品岗" - 下拉选择组件
	// 框架标签：validate:"required" - 必填字段
	Position string `json:"position" runner:"name:应聘职位" widget:"type:select;options:前端开发岗,后端开发岗,运营岗,运维岗,美术岗,设计岗,产品岗" validate:"required"`

	// 框架标签：widget:"type:select;options:北京,上海,深圳,广州,南京,武汉,成都,重庆,杭州" - 下拉选择组件
	// 框架标签：validate:"required" - 必填字段
	WorkCity string `json:"work_city" runner:"name:期望工作地" widget:"type:select;options:北京,上海,深圳,广州,南京,武汉,成都,重庆,杭州" validate:"required"`

	// 框架标签：widget:"type:select;options:应届生,1年以下,1-3年,3-5年,5-10年,10年以上" - 下拉选择组件
	// 框架标签：validate:"required" - 必填字段
	Experience string `json:"experience" runner:"name:工作经验" widget:"type:select;options:应届生,1年以下,1-3年,3-5年,5-10年,10年以上" validate:"required"`

	// 条件字段：当工作经验=应届生时显示毕业时间字段
	// 框架标签：widget:"type:number;min:2020;max:2030;unit:年" - 数字输入组件，最小值2020，最大值2030，单位年
	// 框架标签：validate:"required_if=experience 应届生,min=2020,max=2030" - 当工作经验=应届生时必填
	GraduationYear int `json:"graduation_year" runner:"name:毕业年份" widget:"type:number;min:2020;max:2030;unit:年" data:"default_value:2024;example:2024" validate:"required_if=experience 应届生,min=2020,max=2030"`

	// 条件字段：当工作经验=应届生时显示实习经历
	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：validate:"required_if=experience 应届生" - 当工作经验=应届生时必填
	InternshipExperience string `json:"internship_experience" runner:"name:实习经历" widget:"type:input;mode:text_area" data:"example:在XX公司实习3个月，负责前端开发" validate:"required_if=experience 应届生"`

	// 条件字段：当工作经验≠应届生时显示项目经验
	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：validate:"required_unless=experience 应届生" - 当工作经验≠应届生时必填
	ProjectExperience string `json:"project_experience" runner:"name:项目经验" widget:"type:input;mode:text_area" data:"example:负责XX项目的架构设计和开发" validate:"required_unless=experience 应届生"`

	// 框架标签：widget:"type:select;options:5K以下,5K-10K,10K-15K,15K-20K,20K-30K,30K以上" - 下拉选择组件
	// 框架标签：validate:"required" - 必填字段
	Salary string `json:"salary" runner:"name:期望薪资" widget:"type:select;options:5K以下,5K-10K,10K-15K,15K-20K,20K-30K,30K以上" validate:"required"`

	// 条件字段：当期望薪资=30K以上时显示具体薪资
	// 框架标签：widget:"type:number;min:30000;max:100000;unit:元" - 数字输入组件，最小值30000，最大值100000，单位元
	// 框架标签：validate:"required_if=salary 30K以上,min=30000,max=100000" - 当期望薪资=30K以上时必填
	SpecificSalary int `json:"specific_salary" runner:"name:具体期望薪资" widget:"type:number;min:30000;max:100000;unit:元" data:"example:35000" validate:"required_if=salary 30K以上,min=30000,max=100000"`

	// 框架标签：widget:"type:file_upload;accept:.pdf,.doc,.docx;max_size:10MB" - 文件上传组件
	// 框架标签：accept:.pdf,.doc,.docx - 允许上传的文件类型
	// 框架标签：validate:"required" - 必填字段
	Resume *files.Files `json:"resume" runner:"name:简历附件" widget:"type:file_upload;accept:.pdf,.doc,.docx;max_size:10MB" validate:"required"`

	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件
	// 框架标签：validate:"required,min=20,max=500" - 必填字段，长度20-500字符
	Introduce string `json:"introduce" runner:"name:自我介绍" widget:"type:input;mode:text_area" validate:"required,min=20,max=500"`

	// 框架标签：widget:"type:multiselect;options:开源项目,AI编程,全栈开发,经验丰富,应届生,懂运维,数据分析;allow_create:true" - 多选组件
	// 框架标签：allow_create:true - 允许创建自定义标签
	// 注意：multiselect有两种类型，一种string的会用,号分隔多个值，第二种[]string，会直接用切片存储多个值
	// 为了方便存储到数据库我们选择用string
	Tags string `json:"tags" runner:"name:个人标签" widget:"type:multiselect;options:开源项目,AI编程,全栈开发,经验丰富,应届生,懂运维,数据分析;allow_create:true"`
}

// 简历投递响应结构
type HrRecruitmentApplyResp struct {
	// 框架标签：widget:"type:switch;true_label:成功;false_label:失败" - 开关组件，显示成功/失败状态
	Success bool `json:"success" runner:"name:是否成功" widget:"type:switch;true_label:成功;false_label:失败"`

	// 框架标签：widget:"type:input;mode:text_area" - 多行文本区域组件，显示处理结果信息
	Message string `json:"message" runner:"name:处理结果" widget:"type:input;mode:text_area"`

	// 框架标签：widget:"type:number" - 数字显示组件，显示简历ID
	ResumeID int `json:"resume_id" runner:"name:简历ID" widget:"type:number"`

	// 框架标签：widget:"type:input" - 文本输入框组件，显示简历状态
	Status string `json:"status" runner:"name:简历状态" widget:"type:input"`

	// 框架标签：widget:"type:input" - 文本输入框组件，显示个人标签
	Tags string `json:"tags" runner:"name:个人标签" widget:"type:input"`

	// 框架标签：widget:"type:input" - 文本输入框组件，显示提交时间
	SubmitTime string `json:"submit_time" runner:"name:提交时间" widget:"type:input"`

	// 函数跳转链接 - 支持点击后跳转到简历列表页面
	// 框架标签：widget:"type:function_link;auto_run:true;target:_blank" - 函数跳转组件，自动运行，新窗口打开
	ListLink string `json:"list_link" runner:"name:查看我的简历" widget:"type:function_link;auto_run:true;target:_blank"`
}

// 简历列表请求结构
type HrRecruitmentListReq struct {
	// 框架标签：runner:"-" - 隐藏搜索，分页，等请求参数（无需在前端显示）
	// 这个会自动处理这个数据表全部字段的自动实现分页，查询，排序等等
	query.SearchFilterPageReq `runner:"-"`
}

// 简历投递处理函数
func HrRecruitmentApply(ctx *runner.Context, req *HrRecruitmentApplyReq, resp response.Response) error {
	// 获取数据库连接
	db := ctx.MustGetOrInitDB()

	// 获取当前用户信息
	userInfo := ctx.GetUserInfo()

	// 创建简历记录
	resume := &HrRecruitment{
		Name:       req.Name,
		Phone:      req.Phone,
		Email:      req.Email,
		Age:        req.Age,
		Gender:     req.Gender,
		Education:  req.Education,
		Position:   req.Position,
		WorkCity:   req.WorkCity,
		Experience: req.Experience,
		Salary:     req.Salary,
		Resume:     req.Resume,
		Introduce:  req.Introduce,
		Tags:       req.Tags,
		Status:     "待面试", // 默认状态为待面试
		CreateBy:   userInfo.Username,
	}

	// 保存简历到数据库
	if err := db.Create(resume).Error; err != nil {
		return fmt.Errorf("简历投递失败: %v", err)
	}

	//'eq': '等于',
	//'not_eq': '不等于',
	//'like': '包含',
	//'not_like': '不包含',
	//'in': '属于',
	//'not_in': '不属于',
	//'gt': '大于',
	//'gte': '大于等于',
	//'lt': '小于',
	//'lte': '小于等于',

	// 生成跳转到列表页面的链接，携带ID参数定位到刚创建的记录，跳转到table函数需要用search里的标签配合下面的语句，form函数的话正常用那种query即可
	listLink := ctx.GetFunctionUrl(&runner.FunctionUrl{
		Title:        "查看我的简历",
		RouterGroup:  RouterGroup,
		FunctionName: "hr_recruitment_list",              // 跳转到列表页面,列表页面的参数相对比较特殊，需要用标签来
		Query:        fmt.Sprintf("eq=id:%v", resume.ID), // 携带ID参数定位到刚创建的记录,&like=name:%s 这里可以不加，只是为了演示一下
		//in=education:高中,大专  这里是查询高中和大专的记录
		//gte=graduation_year:2019 毕业年份大雨等于2019的记录
		//like=name:beiluo 名字包含beiluo的记录
		//gte=graduation_year:2019&in=education:高中,大专  查询2019年及其以后高中或者大专毕业的记录
	})
	//

	// 返回成功响应
	return resp.Form(&HrRecruitmentApplyResp{
		Success:    true,
		Message:    "您的简历已成功投递！点击下方链接查看您的简历状态。",
		ResumeID:   resume.ID,
		Status:     "待面试",
		Tags:       resume.Tags,
		SubmitTime: "刚刚",
		ListLink:   listLink,
	}).Build()
}

// 简历列表处理函数
func HrRecruitmentList(ctx *runner.Context, req *HrRecruitmentListReq, resp response.Response) error {
	// 获取数据库连接
	db := ctx.MustGetOrInitDB()
	var rows []*HrRecruitment

	// 自动处理分页、搜索、排序
	queryBuilder := resp.Table(&rows).AutoPaginated(db, &HrRecruitment{}, &req.SearchFilterPageReq)

	// 列表页面不需要跳转链接，因为列表本身就显示了投递状态
	// 用户可以直接在列表中查看所有简历的状态信息

	return queryBuilder.Build()
}

// 简历投递配置
var HrRecruitmentApplyOption = &runner.FormFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "简历投递",                           // API中文名称
		ApiDesc:      "用户投递简历申请职位",                     // API描述
		Tags:         []string{"招聘系统", "简历投递", "求职申请"}, // 框架自动生成标签分类
		CreateTables: []interface{}{&HrRecruitment{}},  // 创建数据表
		Request:      &HrRecruitmentApplyReq{},         // 请求参数
		Response:     &HrRecruitmentApplyResp{},        // 响应参数
		Group:        HrRecruitmentGroup,               // 设置函数组
	},
}

// 简历管理配置
var HrRecruitmentListOption = &runner.TableFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "简历管理",                                  // API中文名称
		ApiDesc:      "HR简历管理系统，支持完整的CRUD操作",                  // API描述
		Tags:         []string{"招聘系统", "简历管理", "HR管理"},        // 框架自动生成标签分类
		CreateTables: []interface{}{&HrRecruitment{}},         // 创建数据表
		Request:      &HrRecruitmentListReq{},                 // 请求参数
		Response:     query.PaginatedTable[[]HrRecruitment]{}, // 响应参数
		Group:        HrRecruitmentGroup,                      // 设置函数组
	},

	// 自动CRUD
	AutoCrudTable: &HrRecruitment{},

	// 新增记录回调
	OnTableAddRows: func(ctx *runner.Context, req *usercall.OnTableAddRowsReq) (*usercall.OnTableAddRowsResp, error) {
		db := ctx.MustGetOrInitDB()
		var addRows []*HrRecruitment
		if err := req.DecodeBy(&addRows); err != nil {
			return nil, err
		}
		for _, row := range addRows {
			row.CreateBy = ctx.GetUserInfo().Username
		}
		err := db.Create(&addRows).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableAddRowsResp{}, nil
	},

	// 更新记录回调
	OnTableUpdateRows: func(ctx *runner.Context, req *usercall.OnTableUpdateRowsReq) (*usercall.OnTableUpdateRowsResp, error) {
		db := ctx.MustGetOrInitDB()
		var updateRow HrRecruitment
		if err := req.DecodeBy(&updateRow); err != nil {
			return nil, err
		}
		err := db.Where("id in (?)", req.GetIds()).Updates(&updateRow).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableUpdateRowsResp{}, nil
	},

	// 删除记录回调
	OnTableDeleteRows: func(ctx *runner.Context, req *usercall.OnTableDeleteRowsReq) (*usercall.OnTableDeleteRowsResp, error) {
		db := ctx.MustGetOrInitDB()
		err := db.Delete(&HrRecruitment{}, req.GetIds()).Error
		if err != nil {
			return nil, err
		}
		return &usercall.OnTableDeleteRowsResp{}, nil
	},
}

// 路由注册
func init() {
	// 注册简历投递路由
	runner.Post(RouterGroup+"/hr_recruitment_apply", HrRecruitmentApply, HrRecruitmentApplyOption)
	// 注册简历管理路由
	runner.Get(RouterGroup+"/hr_recruitment_list", HrRecruitmentList, HrRecruitmentListOption)
}


```