# function-go 框架介绍

## 项目背景

function-go是一个**Go语言云函数开发框架**，主要为了方便大模型依照这个框架生成可以直接构建的应用。

## 核心能力

### 1. 文件即是函数（应用）
在function-go中，一个Go文件就是一个完整的应用，包含：
- 数据模型定义
- API接口注册
- 业务逻辑处理
- 自动生成Web界面

### 2. 结构体参数即是组件
通过结构体标签定义UI组件，自动生成表单和表格：

```go
type UserReq struct {
    // 自动生成输入框组件
    Name string `json:"name" runner:"name:用户名" widget:"type:input" validate:"required"`
    
    // 自动生成数字输入框组件
    Age int `json:"age" runner:"name:年龄" widget:"type:number;min:1;max:120;unit:岁" validate:"required"`
    
    // 自动生成下拉选择框组件
    Role string `json:"role" runner:"name:用户角色" widget:"type:select;options:管理员,普通用户,访客" validate:"required"`
}
```

### 3. 自动建表能力（CreateTables）
只需将结构体放入 `CreateTables`，框架会自动在数据库中创建对应表结构，无需手写SQL。例如：

```go
var CallbackDemoOption = &runner.FormFunctionOptions{
    BaseConfig: runner.BaseConfig{
        // ...
        CreateTables: []interface{}{&UserProfile{}, &Company{}},
        // ...
    },
}
```
- 结构体字段支持GORM标签，主键、索引、注释等自动生成。
- 适合大模型和开发者一键生成业务表。

### 4. 数据库集成与操作
- ctx（*runner.Context）提供 `MustGetOrInitDB()` 方法，返回的就是**gorm的*gorm.DB对象**，可直接用GORM所有能力进行增删改查、事务、复杂查询等。
- 推荐配合CreateTables自动建表，开发体验极佳。

```go
// 获取gorm.DB对象
db := ctx.MustGetOrInitDB()

// 直接用GORM操作
var users []User
err := db.Where("age > ?", 18).Find(&users).Error
```

### 5. 提供丰富的组件类型
- **input**: 文本输入框（支持普通文本、密码、多行文本）
- **number**: 数字输入框（支持范围限制、单位、精度）
- **select**: 下拉选择框（支持单选、多选）
- **checkbox**: 复选框（支持多选）
- **radio**: 单选框
- **switch**: 开关组件
- **slider**: 滑块组件
- **color**: 颜色选择器
- **datetime**: 日期时间选择器
- **multiselect**: 多选组件（支持固定选项多选）
- **tag**: 标签组件
- **file_upload**: 文件上传组件
- **file_display**: 文件展示组件
- **list_input**: 列表输入组件
- **form**: 表单组件

### 6. 渲染类型
- **form**: 渲染出表单界面，用于数据输入
- **table**: 渲染出标准的Element Plus表格，支持搜索、排序、分页等

### 7. 函数级别回调和字段级别回调
- **函数级别回调**: 在API创建时、页面加载时执行
- **字段级别回调**: 在字段值变化时执行自定义逻辑

## 快速开始

### 1. form函数实战示例：字符串反转

#### 用户需求
我需要一个字符串反转的功能，可以输入字符串，然后给出反转的结果。

#### 示例代码


```go
//文件名： reverse.go
package reverse

import (
    "github.com/yunhanshu-net/function-go/pkg/dto/response"
    "github.com/yunhanshu-net/function-go/runner"
)

// 1. 请求结构体（决定表单字段和校验规则）
type ReverseReq struct {
    Text string `json:"text" runner:"name:待反转内容" widget:"type:input" data:"default_value:hello" validate:"required"`
}

// 2. 响应结构体（决定结果展示）
type ReverseResp struct {
    Result string `json:"result" runner:"name:反转结果" widget:"type:input;mode:text_area"`
}

// 3. 业务处理函数（只做核心业务，校验交给标签）
func ReverseHandler(ctx *runner.Context, req *ReverseReq, resp response.Response) error {
    // 只做业务处理，不做参数校验
    reversed := reverseString(req.Text)
    return resp.Form(&ReverseResp{
        Result: reversed,
    }).Build()
}

// 字符串反转工具函数
func reverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

// 4. 注册API
var ReverseOption = &runner.FormFunctionOptions{
    BaseConfig: runner.BaseConfig{
        ChineseName:  "字符串反转演示",
        ApiDesc:      "输入内容，返回其反转结果。内容不能为空。",
        Tags:         []string{"input", "字符串", "表单演示"},
        Request:      &ReverseReq{},
        Response:     &ReverseResp{},
    },
}

func init() {
	runner.Post(RouterGroup+"/reverse", ReverseHandler, ReverseOption)
}
```

#### 前端表现说明
- 该函数会在前端自动渲染为一个表单，包含“待反转内容”输入框。
- 用户输入内容后点击“运行”或“提交”，后端处理后，结果会以表单形式展示（如“反转结果”多行文本框）。
- 校验规则自动生效，输入为空时前端会自动提示。

#### 规范说明
- 参数校验：全部靠 `validate` 标签，业务函数只做核心逻辑。
- 结构体标签：写全，前端自动生成表单和校验。
- 响应构建：`resp.Form(...)` 返回结果，自动渲染为表单。
- 配置类型：form函数使用 `runner.FormFunctionOptions`，table函数使用 `runner.TableFunctionOptions`。


---

### 2. table函数实战示例：图书管理系统

#### 用户需求
我需要一个图书管理系统，字段如下：  
书名：填写图书名称  
作者：填写作者名字  
价格：填写图书价格  
库存：填写库存数量  
状态：选择“热销”、“预售”或“已售罄”  
上架：开关控制图书是否上架销售

#### 示例代码

```go
package book

import (
	"github.com/yunhanshu-net/function-go/pkg/dto/response"
	"github.com/yunhanshu-net/function-go/runner"
	"github.com/yunhanshu-net/pkg/query"
	"gorm.io/gorm"
)

// Book 1. 图书数据模型
type Book struct {
	ID        int            `json:"id" gorm:"primaryKey;autoIncrement" runner:"name:ID" permission:"read"`
	CreatedAt int64          `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" widget:"type:datetime;kind:datetime" data:"example:1705292200000" search:"gte,lte" permission:"read"`
	DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index" runner:"-"` // runner:"-" 表示不渲染该字段
	Title     string         `json:"title" runner:"name:书名" widget:"type:input" search:"like" validate:"required,min=2,max=50"`                          // 书名，必填，2-50字
	Author    string         `json:"author" runner:"name:作者" widget:"type:input" search:"like" validate:"required,min=2,max=20"`                        // 作者，必填，2-20字
	Price     float64        `json:"price" runner:"name:价格" widget:"type:number;min:0;precision:2;prefix:￥" search:"gte,lte" validate:"required,min=0"`            // 价格，必填，最小0元，支持区间搜索
	Stock     int            `json:"stock" runner:"name:库存" widget:"type:number;min:0;unit:本" search:"gte,lte" validate:"required,min=0"`                         // 库存，必填，最小0，支持区间搜索
	Status    string         `json:"status" runner:"name:状态" widget:"type:select;options:热销,预售,已售罄" search:"in" validate:"required,oneof=热销 预售 已售罄"` // 状态，必填，枚举，支持多选筛选
	OnSale    bool           `json:"on_sale" runner:"name:上架" widget:"type:switch;true_label:已上架;false_label:未上架" data:"default_value:true" search:"eq" validate:"required"`   // 上架，开关组件，支持等值筛选
}

func (b *Book) TableName() string {
	return "book"
}

// BookListReq 2. 请求结构体（自动包含分页和搜索）
type BookListReq struct {
	query.SearchFilterPageReq `runner:"-"`
}

// BookList 3. table函数处理逻辑
func BookList(ctx *runner.Context, req *BookListReq, resp response.Response) error {
	db := ctx.MustGetOrInitDB() // gorm db
	var books []Book
	// 自动分页和搜索
	return resp.Table(&books).AutoPaginated(db, &Book{}, &req.SearchFilterPageReq).Build()
}

// BookListOption 4. 注册API
var BookListOption = &runner.TableFunctionOptions{
	BaseConfig: runner.BaseConfig{
		ChineseName:  "图书列表",
		ApiDesc:      "展示图书列表，支持分页和搜索。",
		Tags:         []string{"图书管理", "表格演示"},
		Request:      &BookListReq{},
		Response:     query.PaginatedTable[[]Book]{},
		CreateTables: []interface{}{&Book{}},   // 这里注册的表会在程序构建时候自动创建
	},
	AutoCrudTable: &Book{},                  // 围绕着Book自动生成Book表的新增，修改，删除操作接口，前端可以直接操作
}

func init() {
	runner.Get(RouterGroup+"/book_list", BookList, BookListOption)
}
```

#### 前端表现说明
- 该API会在前端自动渲染为一个表格，展示所有图书的ID、书名、作者、价格、库存、状态、上架状态、创建时间等字段。
- 表格上方会自动生成搜索栏：书名/作者为模糊搜索，价格/库存为区间搜索，状态为下拉多选，上架为开关筛选，创建时间为区间日期选择器。
- 支持分页、排序、翻页等交互，表格样式为标准Element Plus表格。
- 注册了 AutoCrudTable 后，前端自动支持新增、修改、删除等操作，无需手写接口。
- 软删除字段（DeletedAt）前端默认不展示，但后端自动支持“假删除”。
- 用户可直接在表格上方输入关键词、选择区间、切换开关等方式进行多条件筛选，体验与企业级管理后台一致。

#### 规范说明
- 基础字段：建议所有业务表都包含ID、创建时间、软删除等通用字段。
- search标签：如 `search:"like"`、`search:"in"` 等，前端会自动生成对应的搜索输入框或下拉筛选。
- 分页请求：`query.SearchFilterPageReq runner:"-"` 是table函数的固定写法，自动支持分页、排序、搜索等功能。
- 表名方法：`TableName` 必须实现，否则自动建表和查询会失败。
- 响应构建：`resp.Table(...)` 返回结果，自动渲染为表格。
- 配置类型：table函数使用 `runner.TableFunctionOptions`，form函数使用 `runner.FormFunctionOptions`。
- 自动CRUD：通过 `AutoCrudTable` 自动生成增删改查界面和功能。

---

### 3. 文件上传存储实战示例：CRM工单管理系统

#### 用户需求
我需要一个工单管理系统，用于记录和处理客户提交的问题工单。包含以下字段：
- 工单标题
- 问题描述  
- 优先级：选择优先级（低、中、高，默认中）
- 工单状态：选择状态（待处理、处理中、已完成、已关闭，默认待处理）
- 联系电话
- 备注
- 附件（支持.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.jpg,.png,.gif,.zip,.rar，最大10MB）

#### 示例代码

```go
package crm

import (
    "github.com/yunhanshu-net/function-go/pkg/dto/response"
    "github.com/yunhanshu-net/function-go/runner"
    "github.com/yunhanshu-net/pkg/query"
    "github.com/yunhanshu-net/pkg/typex/files"
    "gorm.io/gorm"
)

// 工单表：客户问题工单管理，独立模块，可直接引用
type CrmTicket struct {
    ID int `json:"id" gorm:"primaryKey;autoIncrement" runner:"name:工单ID" permission:"read"`

    // 时间字段：使用datetime组件，毫秒时间戳，permission控制权限
    CreatedAt int64 `json:"created_at" gorm:"autoCreateTime:milli" runner:"name:创建时间" widget:"type:datetime;kind:datetime" permission:"read"`
    UpdatedAt int64 `json:"updated_at" gorm:"autoUpdateTime:milli" runner:"name:更新时间" widget:"type:datetime;kind:datetime" permission:"read"`

    // 软删除：runner:"-"隐藏字段，纯后端逻辑
    DeletedAt gorm.DeletedAt `json:"deleted_at" gorm:"index" runner:"-"`

    // 业务字段：validate标签自动验证，search标签自动生成搜索
    Title       string `json:"title" gorm:"column:title" runner:"name:工单标题" widget:"type:input" search:"like" validate:"required,min=2,max=200"`
    Description string `json:"description" gorm:"column:description" runner:"name:问题描述" widget:"type:input;mode:text_area" search:"like" validate:"required,min=10"`
    Priority    string `json:"priority" gorm:"column:priority" runner:"name:优先级" widget:"type:select;options:低,中,高" data:"default_value:中" search:"in" validate:"required,oneof=低,中,高"`
    Status      string `json:"status" gorm:"column:status" runner:"name:工单状态" widget:"type:select;options:待处理,处理中,已完成,已关闭" data:"default_value:待处理" search:"in" validate:"required,oneof=待处理,处理中,已完成,已关闭"`
    Phone       string `json:"phone" gorm:"column:phone" runner:"name:联系电话" widget:"type:input" search:"like" validate:"required,min=11,max=20"`
    Remark      string `json:"remark" gorm:"column:remark" runner:"name:备注" widget:"type:input;mode:text_area" search:"like"`

    // 文件上传：*files.Files类型，gorm:type:json，支持多文件
    Attachment *files.Files `json:"attachment" gorm:"column:attachment;type:json" runner:"name:附件" widget:"type:file_upload;multiple:true;max_size:10MB;accept:.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.jpg,.png,.gif,.zip,.rar"`
}

func (CrmTicket) TableName() string { return "crm_ticket" }

// 标准table函数请求参数：包含分页、搜索、排序功能
type CrmTicketListReq struct {
    query.SearchFilterPageReq `runner:"-"` // 分页请求：框架自动生成分页、搜索、排序功能
}

// 标准table函数：自动处理分页查询，返回表格数据
func CrmTicketList(ctx *runner.Context, req *CrmTicketListReq, resp response.Response) error {
    db := ctx.MustGetOrInitDB()
    var rows []CrmTicket
    return resp.Table(&rows).AutoPaginated(db, &CrmTicket{}, &req.SearchFilterPageReq).Build()
}

var CrmTicketListOption = &runner.TableFunctionOptions{
    BaseConfig: runner.BaseConfig{
        ChineseName:  "CRM工单管理-列表",
        ApiDesc:      "CRM工单基础信息管理，支持工单创建、查询、状态管理和附件上传。",
        Tags:         []string{"CRM", "工单管理", "客户服务"},
        Request:      &CrmTicketListReq{},
        Response:     query.PaginatedTable[[]CrmTicket]{},
        CreateTables: []interface{}{&CrmTicket{}}, // 自动建表：函数创建时自动创建数据表
    },
    AutoCrudTable: &CrmTicket{}, // 自动CRUD：自动生成增删改查界面和功能
}

func init() {
    // 路由注册：table函数使用GET请求，支持分页和搜索
    runner.Get("/crm/crm_ticket_list", CrmTicketList, CrmTicketListOption)
}
```

#### 前端表现说明
- 该API会在前端自动渲染为一个表格，展示所有工单的ID、标题、描述、优先级、状态、联系电话、备注、附件、创建时间等字段。
- 表格上方会自动生成搜索栏：标题/描述/备注为模糊搜索，优先级/状态为下拉多选，创建时间为区间日期选择器。
- 支持分页、排序、翻页等交互，表格样式为标准Element Plus表格。
- 注册了 AutoCrudTable 后，前端自动支持新增、修改、删除等操作，无需手写接口。
- **文件上传功能**：用户可以在新增/编辑工单时上传多个附件文件，支持多种格式，自动限制文件大小。
- **文件存储**：附件文件会自动存储到数据库的JSON字段中，支持文件元数据管理。

#### 文件上传核心要点
- **字段类型**：使用 `*files.Files` 类型，这是function-go框架的标准文件类型
- **数据库存储**：使用 `gorm:"type:json"` 标签，文件信息以JSON格式存储在数据库中
- **组件配置**：`widget:"type:file_upload;multiple:true;max_size:10MB;accept:.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.jpg,.png,.gif,.zip,.rar"`
- **多文件支持**：`multiple:true` 支持一次上传多个文件
- **文件大小限制**：`max_size:10MB` 自动限制文件大小，保护系统安全
- **文件类型限制**：`accept` 指定允许的文件扩展名

---

### 4. 文件处理实战示例：PDF加密解密工具

#### 用户需求
我需要一个PDF加密/解密工具，可以：
- 为PDF文件设置加密口令（用户与所有者同口令，AES-256）
- 移除PDF口令（需提供正确口令）
- 支持批量处理多个PDF文件

#### 示例代码

```go
package pdf

import (
    "fmt"
    "os"
    "path/filepath"

    pdfapi "github.com/pdfcpu/pdfcpu/pkg/api"
    pdfmodel "github.com/pdfcpu/pdfcpu/pkg/pdfcpu/model"
    "github.com/yunhanshu-net/function-go/pkg/dto/response"
    "github.com/yunhanshu-net/function-go/runner"
    "github.com/yunhanshu-net/pkg/typex/files"
)

// PDF加密请求
type PdfEncryptReq struct {
    Files    *files.Files `json:"files" runner:"name:PDF文件" widget:"type:file_upload;accept:.pdf;multiple:true" validate:"required"`
    Password string       `json:"password" runner:"name:口令" widget:"type:input;mode:password" validate:"required,min=1"`
}

// PDF加密响应
type PdfEncryptResp struct {
    Result *files.Files `json:"result" runner:"name:加密结果" widget:"type:file_display"`
}

func PdfEncryptHandle(ctx *runner.Context, req *PdfEncryptReq, resp response.Response) error {
    if req.Files == nil || req.Files.GetFileCount() == 0 {
        return fmt.Errorf("请上传PDF文件")
    }
    if req.Password == "" {
        return fmt.Errorf("请输入加密口令")
    }
    defer req.Files.CleanupLocalFiles()

    // 创建临时工作目录
    baseDir, err := ctx.FS().TempUniqueDir("pdf_task", "encrypt")
    if err != nil {
        return err
    }
    defer os.RemoveAll(baseDir)

    // 创建输出文件集合
    out := ctx.FS().NewTemporaryFiles()
    defer out.CleanupLocalFiles()

    // 配置加密参数
    conf := pdfmodel.NewAESConfiguration(req.Password, req.Password, 256)
    
    // 处理每个PDF文件
    for _, f := range req.Files.GetFiles() {
        inPath, e := f.GetLocalPath(ctx)
        if e != nil {
            return fmt.Errorf("读取PDF失败: %s", f.Name)
        }
        
        outPath := filepath.Join(baseDir, filepath.Base(inPath))
        if e := pdfapi.EncryptFile(inPath, outPath, conf); e != nil {
            return fmt.Errorf("加密失败(%s)：%v", f.Name, e)
        }
        
        if e := out.AddFileFromPath(outPath); e != nil {
            return e
        }
    }
    
    return resp.Form(&PdfEncryptResp{Result: out}).Build()
}

var PdfEncryptOption = &runner.FormFunctionOptions{
    BaseConfig: runner.BaseConfig{
        EnglishName:  "pdf_encrypt",
        ChineseName:  "PDF加密",
        ApiDesc:      "为PDF设置口令（用户与所有者同口令，AES-256）",
        Tags:         []string{"PDF", "安全"},
        Request:      &PdfEncryptReq{},
        Response:     &PdfEncryptResp{},
        FunctionType: runner.FunctionTypeDynamic,
    },
}

func init() {
    runner.Post(RouterGroup+"/pdf_encrypt", PdfEncryptHandle, PdfEncryptOption)
}
```

#### 文件处理核心要点
- **文件上传**：使用 `*files.Files` 类型接收用户上传的文件
- **临时目录**：使用 `ctx.FS().TempUniqueDir()` 创建唯一的临时工作目录
- **文件处理**：调用第三方库（如pdfcpu）进行文件处理
- **结果返回**：将处理后的文件添加到输出文件集合，返回给用户
- **资源清理**：使用 `defer` 确保临时文件和目录被正确清理
- **错误处理**：提供详细的错误信息，帮助用户定位问题

#### 文件处理流程
1. **文件接收**：用户上传PDF文件到 `*files.Files` 字段
2. **临时存储**：文件自动存储到临时目录，获取本地路径
3. **业务处理**：调用PDF处理库进行加密/解密操作
4. **结果收集**：将处理后的文件添加到输出文件集合
5. **资源清理**：自动清理临时文件和目录
6. **文件返回**：将处理结果以 `*files.Files` 类型返回给用户

## 一句话总结

**function-go = Go云函数框架 + 自动UI生成器 + 自动建表 + 数据库ORM**

让大模型能够快速生成完整的Web应用，一个Go文件就是一个完整的应用。

---

## 回调机制简介

> 所有回调相关配置均在 `TableFunctionOptions`或者`FormFunctionOptions` 结构体中设置，通常在注册 API 时一并传入。例如：
>
> ```go
> var DemoOption = &runner.TableFunctionOptions{
>     // ...
>     OnPageLoad: ...,
>     OnInputFuzzyMap: ...,
> }
> runner.Post("/demo/path", DemoHandler, DemoOption)
> ```
>
> 这样可以将所有与该API相关的回调逻辑集中管理，便于维护和理解。

function-go 支持灵活的回调机制，极大提升了动态业务场景下的自动化和智能化能力。

### 1. OnPageLoad（函数级别回调）
- 用于页面加载时初始化参数，常见于需要动态获取数据作为初始值的场景。
- 回调函数签名：
  ```go
  OnPageLoad: func(ctx *runner.Context, resp response.Response) (initData *usercall.OnPageLoadResp, err error)
  ```
  - ctx：请求上下文，包含用户信息、请求参数等
  - resp：用于返回前端的初始化数据（如表单、提示等）
  - 返回值：
    - initData：结构体，通常包含 Request 字段（类型为你的请求结构体），用于给前端表单字段动态赋初值
    - err：错误信息，返回非nil时前端会提示
- 典型业务场景：
  - 用户进入页面时，自动查询数据库获取最近一次操作记录，作为表单初始值
  - 根据当前登录用户信息，动态填充部门、姓名等字段
  - 结合外部API结果，动态生成推荐参数
- 推荐用法：通过 `ctx.GetUserInfo()` 获取用户信息（返回 UserInfo 结构体），无需判断未登录报错，未登录时直接返回空初始化参数即可。
- 示例代码（参考 @callback_demo.go）：

```go
OnPageLoad: func(ctx *runner.Context, resp response.Response) (initData *usercall.OnPageLoadResp, err error) {
    // 1. 获取当前用户信息
    userInfo := ctx.GetUserInfo()
    // 2. 查询数据库，获取最近一条记录（如已登录）
    var lastProfile UserProfile
    db := ctx.MustGetOrInitDB()
    if userInfo.IsLoggedIn {
        db.Where("username = ?", userInfo.Username).Order("created_at desc").First(&lastProfile)
    }
    // 3. 构造初始化参数
    initReq := CallbackDemoReq{}
    if userInfo.IsLoggedIn {
        initReq.Username = userInfo.Username
        initReq.Department = lastProfile.Department
        // ...其他字段
    }
    // 4. 返回给前端，自动填充表单（未登录时返回空参数即可）
    return &usercall.OnPageLoadResp{Request: initReq}, nil
}
```
- 注意事项：
  - OnPageLoad 返回的 Request 字段会自动作为表单初始值，优先级高于 default_value
  - 可以结合 ctx.GetUserInfo() 获取用户、组织、权限等上下文信息，实现个性化初始化

### 2. OnInputFuzzyMap（字段级别回调）
- 用于输入框等组件的"动态联想/模糊搜索"场景。
- 只有在用户输入时才会触发，实时从数据库或其他数据源返回候选项。
- 回调函数签名：
  ```go
  OnInputFuzzyMap: map[string]runner.OnInputFuzzy{
      "字段名": func(ctx *runner.Context, req *usercall.OnInputFuzzyReq) (*usercall.OnInputFuzzyResp, error) {
          // ...
      },
  }
  ```
  - ctx：请求上下文，包含用户信息、请求参数等
  - req：包含当前输入内容（req.Value）、其他上下文参数
  - 返回值：
    - *usercall.OnInputFuzzyResp：结构体，Values 字段为候选项列表（每项为 InputFuzzyItem，仅包含 Value 字段，Value 既作为下拉展示文本也作为实际取值）
    - error：错误信息，返回非nil时前端会提示
- 典型业务场景：
  - 公司名称输入框，用户输入2个字后，自动联想并下拉展示相关公司
  - 用户搜索输入框，输入关键字后动态展示匹配的用户
  - 地点、标签等字段的智能补全
- 示例代码（参考 @callback_demo.go）：

```go
OnInputFuzzyMap: map[string]runner.OnInputFuzzy{
    "company_search": func(ctx *runner.Context, req *usercall.OnInputFuzzyReq) (*usercall.OnInputFuzzyResp, error) {
        // 【当前场景】company_search是单选字段，只返回静态信息，不做聚合计算
        // 【目标字段】为 CallbackDemoReq.CompanySearch 提供公司选择数据
        var companies []Company
        db := ctx.MustGetOrInitDB()

        if req.IsByFiledValues() {
            // 多值查询：使用 IN 查询，这里必须用 db = db.Where
            db = db.Where("id in ?", req.GetFiledValues())
        } else if req.IsByFiledValue() {
            // 单值查询：使用等值查询，性能最优
            db = db.Where("id = ?", req.GetFiledValue()).Limit(1)
        } else {
            // 模糊查询：关键字搜索
            db = db.Where("name LIKE ? OR industry LIKE ?", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%").
                Where("status = ?", "正常").
                Limit(10)
        }
        db.Find(&companies)

        items := make([]*usercall.InputFuzzyItem, 0)
        for _, company := range companies {
            items = append(items, &usercall.InputFuzzyItem{
                Value: company.Name,
                Label: fmt.Sprintf("%s - %s", company.Name, company.Industry),
                DisplayInfo: map[string]interface{}{
                    "公司名称": company.Name,
                    "行业":   company.Industry,
                    "地址":   company.Address,
                },
            })
        }

        return &usercall.OnInputFuzzyResp{
            Statistics: map[string]interface{}{
                "搜索规则": "支持公司名称和行业模糊搜索",
                "显示数量": "最多显示10条结果",
            },
            Values: items,
        }, nil
    },
    "user_search": func(ctx *runner.Context, req *usercall.OnInputFuzzyReq) (*usercall.OnInputFuzzyResp, error) {
        // 【当前场景】user_search是单选字段，只返回静态信息，不做聚合计算
        // 【目标字段】为 CallbackDemoReq.UserSearch 提供用户选择数据
        var users []UserProfile
        db := ctx.MustGetOrInitDB()

        if req.IsByFiledValues() {
            // 多值查询：使用 IN 查询，这里必须用 db = db.Where
            db = db.Where("id in ?", req.GetFiledValues())
        } else if req.IsByFiledValue() {
            // 单值查询：使用等值查询，性能最优
            db = db.Where("id = ?", req.GetFiledValue()).Limit(1)
        } else {
            // 模糊查询：关键字搜索
            db = db.Where("username LIKE ? OR email LIKE ? OR department LIKE ?", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%", "%"+req.Keyword()+"%").
                Where("status = ?", "正常").
                Limit(10)
        }
        db.Find(&users)

        items := make([]*usercall.InputFuzzyItem, 0)
        for _, user := range users {
            items = append(items, &usercall.InputFuzzyItem{
                Value: user.Username,
                Label: fmt.Sprintf("%s - %s (%s)", user.Username, user.Email, user.Department),
                DisplayInfo: map[string]interface{}{
                    "用户名": user.Username,
                    "邮箱":  user.Email,
                    "部门":  user.Department,
                },
            })
        }

        return &usercall.OnInputFuzzyResp{
            Statistics: map[string]interface{}{
                "搜索规则": "支持用户名、邮箱和部门模糊搜索",
                "显示数量": "最多显示10条结果",
            },
            Values: items,
        }, nil
    },
}
```
- 注意事项：
  - 字段名需与请求结构体中的字段一致，如 `company_search`、`user_search` 等
  - 返回的 Values 会自动作为下拉候选项展示，Value 既是展示文本也是实际取值
  - 可结合 ctx.GetUserInfo() 实现个性化联想，如只展示当前用户有权限的数据

---

## 标签使用规范

### 1. 核心标签说明

#### json 标签
- **用途**：JSON序列化/反序列化
- **格式**：`json:"字段名"`

#### runner 标签
- **用途**：业务逻辑配置
- **格式**：`runner:"name:显示名称;desc:描述"`

#### widget 标签
- **用途**：UI组件配置
- **格式**：`widget:"type:组件类型;参数1:值1;参数2:值2"`

#### data 标签
- **用途**：数据类型和值配置
- **格式**：`data:"default_value:默认值;example:示例值"`

#### validate 标签
- **用途**：验证规则配置
- **格式**：`validate:"规则1,规则2,规则3"`

#### search 标签
- **用途**：搜索配置（仅table函数）
- **格式**：`search:"搜索类型1,搜索类型2"`

#### permission 标签
- **用途**：权限控制配置（仅table函数）
- **格式**：`permission:"权限类型"`

### 2. 权限控制原则（permission标签，仅table函数）

#### 权限类型说明
- **permission:"read"**：仅可读权限（仅列表显示）
- **permission:"create"**：仅可创建权限（仅新增显示）
- **permission:"update"**：仅可更新权限（仅编辑显示）
- **permission:"create,update"**：可创建可更新权限（新增编辑显示，列表不显示）
- **不写permission标签**：全权限（列表、新增、编辑都显示）

#### 使用场景
```go
type User struct {
    // 系统字段：只读权限
    ID        int    `permission:"read"`
    CreatedAt int64  `permission:"read"`
    
    // 敏感字段：仅创建权限（如密码）
    Password  string `permission:"create"`
    
    // 业务字段：全权限（不写permission标签）
    Name      string
    Email     string
    
    // 特殊字段：仅编辑权限
    LastLogin int64  `permission:"update"`
}
```

### 3. 搜索配置原则（search标签，仅table函数）

#### 搜索类型说明
- **文本字段**：使用 `like` 模糊搜索，`eq` 精确搜索，`not_like` 否定模糊搜索，`not_eq` 否定精确搜索
- **数值字段**：使用 `eq` 等值搜索，`gt,gte,lt,lte` 区间搜索，`not_eq` 否定搜索
- **枚举字段**：使用 `eq` 等值搜索，`in` 多选搜索，`not_eq` 否定等值搜索，`not_in` 否定多选搜索
- **时间字段**：使用 `eq` 等值搜索，`gt,gte,lt,lte` 时间范围搜索，`not_eq` 否定搜索

#### 使用示例
```go
type Product struct {
    // 文本搜索
    Name        string  `search:"like,eq"`
    Description string  `search:"like,not_like"`
    
    // 数值搜索
    Price       float64 `search:"eq,gt,gte,lt,lte"`
    Stock       int     `search:"eq,gt,gte,lt,lte"`
    
    // 枚举搜索
    Status      string  `search:"eq,in,not_eq"`
    Category    string  `search:"eq,in,not_in"`
    
    // 时间搜索
    CreatedAt   int64   `search:"eq,gt,gte,lt,lte"`
}
```

### 4. 验证规则原则（validate标签）

#### 常用验证规则
- **required**：必填验证
- **min/max**：数值范围验证，格式：`min=值, max=值`
- **len**：长度验证，格式：`len=值`
- **oneof**：枚举值验证，格式：`oneof=值1 值2 值3`
- **email**：邮箱格式验证
- **url**：URL格式验证

#### 使用示例
```go
type UserReq struct {
    // 必填验证
    Username string `validate:"required"`
    
    // 长度验证
    Password string `validate:"required,min=6,max=20"`
    
    // 数值范围验证
    Age      int    `validate:"required,min=1,max=120"`
    
    // 枚举验证
    Gender   string `validate:"required,oneof=男 女"`
    
    // 格式验证
    Email    string `validate:"required,email"`
}
```

---

> 本文仅介绍了最常用的两类回调，后续文档会对回调机制进行更详细的说明和高级用法示例。