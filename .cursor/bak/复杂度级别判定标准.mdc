# 函数复杂度级别判定标准

## 🎯 概述

本文档定义了function-go框架中函数复杂度的判定标准，采用S/M双系列分类：

- **S系列**：自闭环单文件函数，无依赖
- **M系列**：有依赖的多文件函数

用于帮助开发者和大模型理解不同函数的复杂程度，便于从简单到复杂逐步学习。

## 📊 复杂度级别定义

### **S系列（自闭环单文件函数，无依赖）**

#### **S1级别（基础）**
**特征描述**：最基础的CRUD操作，无复杂业务逻辑

**技术栈要求**：
- ✅ 基础CRUD操作（增删改查）
- ✅ 简单的validate标签验证
- ✅ 基础的search标签搜索
- ✅ 简单的OnInputValidate回调（唯一性检查等）
- ✅ 基础的permission权限控制
- ✅ 无复杂业务逻辑
- ✅ 无事务处理
- ✅ 无多表关联

**典型应用场景**：
- 基础数据表管理
- 简单的配置管理
- 基础的用户信息管理

**示例**：CRM基础模块（工单、客户、员工、产品、知识库）

---

#### **S2级别（中级）**
**特征描述**：包含基础回调机制，简单的业务逻辑处理

**技术栈要求**：
- ✅ 包含OnTableAddRows回调
- ✅ 包含OnTableUpdateRows回调
- ✅ 包含OnTableDeleteRows回调
- ✅ 包含AutoUpdateConfig配置
- ✅ 简单的业务逻辑处理
- ✅ 基础的自动计算字段
- ✅ 可能一个文件包含多个函数（需要用函数组）
- ✅ 简单的状态管理
- ❌ 不包含复杂的事务处理
- ❌ 不包含多表关联查询
- ❌ 不包含复杂的算法

**典型应用场景**：
- 简单的任务管理系统
- 基础的审批系统
- 简单的状态管理系统

**示例**：任务管理系统
- 任务创建、编辑、删除
- 状态流转：待处理→进行中→已完成
- 简单的自动计算：预计完成时间
- 基础的业务规则：已完成任务不能删除

---

#### **S3级别（高级）**
**特征描述**：相较于S2逻辑更复杂，一般需要form+table混合

**技术栈要求**：
- ✅ 包含S2的所有特性
- ✅ 一般是form+table混合
- ✅ 单table可能不够用
- ✅ 包含多个相关函数
- ✅ 复杂的业务规则
- ✅ 可能一个文件包含多个函数（需要用函数组）
- ✅ 可能包含简单的事务处理
- ❌ 不包含多文件依赖
- ❌ 不包含复杂的架构设计

**典型应用场景**：
- 完整的工单系统（包含提交表单+管理列表）
- 复杂的审批流程系统
- 多功能的项目管理系统

---

### **M系列（有依赖的多文件函数）**

#### **M1级别（基础依赖）**
**特征描述**：简单的数据库连表查询，基本上没太大逻辑

**技术栈要求**：
- ✅ 依赖其他数据表
- ✅ 简单的数据库连表查询
- ✅ 基本的CRUD操作
- ✅ 简单的关联查询
- ❌ 基本上没太大业务逻辑
- ❌ 不包含复杂的回调机制

**典型应用场景**：
- 学生选课系统
- 订单商品关联
- 用户角色关联

**示例**：学生选课系统
- 选课表依赖学生表
- 简单的数据库连表查询
- 基本上没太大逻辑

---

#### **M2级别（中级依赖）**
**特征描述**：在M1之上有简单逻辑，包含一些OnTableAddRows等回调

**技术栈要求**：
- ✅ 包含M1的所有特性
- ✅ 包含一些OnTableAddRows等回调
- ✅ 依赖关系+业务逻辑
- ✅ 可能包含简单的事务处理
- ❌ 不包含复杂的业务流程
- ❌ 不包含多个文件依赖

**典型应用场景**：
- 带业务逻辑的选课系统
- 带状态管理的订单系统
- 带验证的用户权限系统

---

#### **M3级别（高级依赖）**
**特征描述**：相较于M2逻辑更加复杂，一般一个文件包含多个函数

**技术栈要求**：
- ✅ 包含M2的所有特性
- ✅ 一般一个文件包含多个函数
- ✅ 同时可能依赖多个文件
- ✅ 复杂的业务流程
- ✅ 可能包含复杂的事务处理
- ✅ 可能包含多表关联查询
- ❌ 不包含系统级架构设计

**典型应用场景**：
- 完整的电商系统（用户+商品+订单+支付+物流）
- 复杂的企业管理系统
- 多模块的业务系统

## 🔍 判定流程

### **第一步：判断依赖关系**
1. 是否需要其他文件的数据？
2. 是否包含外键关联？

**如果有依赖 → M系列**
**如果无依赖 → S系列**

### **第二步：S系列判定**

#### **S1级别检查**
1. 是否只包含基础CRUD操作？
2. 是否只使用简单的validate和search标签？
3. 是否只使用基础的OnInputValidate回调？

**如果都是"是" → S1级别**

#### **S2级别检查**
1. 是否使用了OnTableAddRows等高级回调？
2. 是否包含AutoUpdateConfig配置？
3. 是否包含简单的业务逻辑？
4. 是否包含基础的自动计算？

**如果有 → S2级别**

#### **S3级别检查**
1. 是否需要form+table混合？
2. 是否包含多个相关函数？
3. 是否包含复杂的业务规则？

**如果有 → S3级别**

### **第三步：M系列判定**

#### **M1级别检查**
1. 是否有简单的数据库连表查询？
2. 是否基本上没太大逻辑？

**如果是 → M1级别**

#### **M2级别检查**
1. 是否包含OnTableAddRows等回调？
2. 是否有简单的业务逻辑？

**如果有 → M2级别**

#### **M3级别检查**
1. 是否一个文件包含多个函数？
2. 是否依赖多个文件？
3. 是否有复杂的业务流程？

**如果有 → M3级别**

## 📝 标签使用规范

### **Metadata标签（头部）**
```xml
<级别>S1</级别>
<函数类型>table</函数类型>
<依赖>无依赖</依赖>
```

### **总结标签（底部）**
```go
//<总结>
//这里是个简单的table函数，用到了OnInputValidate回调
//技术栈：AutoCrudTable自动CRUD、search标签自动搜索、validate标签自动验证、OnInputValidate实时校验、permission权限控制
//复杂度：S1级别，基础CRUD操作，包含唯一性验证，无复杂依赖关系
//</总结>
```

## 🎯 使用建议

### **对于开发者**
1. **从S1开始**：先掌握基础功能，再逐步学习高级特性
2. **渐进式学习**：按照复杂度级别逐步提升技能
3. **依赖管理**：先学习S系列，再学习M系列

### **对于大模型训练**
1. **分级学习**：从S1开始，逐步学习更复杂的功能
2. **依赖识别**：清楚了解模块间的依赖关系
3. **技术栈识别**：快速理解每个函数使用的技术

### **对于项目维护**
1. **功能统计**：统计各类型函数的数量分布
2. **复杂度分析**：分析项目的整体复杂度分布
3. **依赖分析**：了解模块间的依赖关系

## 📚 示例对比

### **S1 vs S2 对比**

| 特性 | S1级别 | S2级别 |
|------|--------|--------|
| CRUD操作 | ✅ 基础CRUD | ✅ 基础CRUD |
| 验证 | ✅ 简单validate | ✅ 简单validate |
| 搜索 | ✅ 基础search | ✅ 基础search |
| 回调 | ✅ OnInputValidate | ✅ OnInputValidate + OnTable* |
| 业务逻辑 | ❌ 简单 | ✅ 简单业务逻辑 |
| 自动计算 | ❌ 无 | ✅ 基础自动计算 |

### **S系列 vs M系列 对比**

| 特性 | S系列 | M系列 |
|------|-------|-------|
| 文件数量 | 单文件 | 多文件 |
| 依赖关系 | 无依赖 | 有依赖 |
| 复杂度 | 相对简单 | 相对复杂 |
| 适用场景 | 独立功能 | 关联功能 |

### **典型S1函数**
```go
// CRM基础模块
- 工单管理：基础CRUD + 简单验证
- 客户管理：基础CRUD + 唯一性检查
- 员工管理：基础CRUD + 唯一性检查
- 产品管理：基础CRUD + 唯一性检查
- 知识库管理：基础CRUD + 唯一性检查
```

### **典型S2函数**
```go
// 任务管理系统
- 包含OnTableAddRows等回调
- 简单的状态管理
- 基础的自动计算
```

### **典型M1函数**
```go
// 学生选课系统
- 选课表依赖学生表
- 简单的数据库连表查询
- 基本上没太大逻辑
```

## 🚀 总结

新的S/M系列复杂度级别判定标准帮助开发者和大模型：

1. **清晰分类**：按依赖关系和复杂度快速识别函数类型
2. **渐进学习**：从简单到复杂逐步提升技能
3. **依赖识别**：清楚了解模块间的依赖关系
4. **维护分析**：便于后期项目维护和功能分析

通过这套标准，可以更好地组织代码结构，指导学习路径，提升开发效率！
description:
globs:
alwaysApply: false
---
