---
description: GORM使用中的常见陷阱和解决方案
globs:
alwaysApply: true
---

# GORM常见陷阱

## ⚠️ 陷阱1：链式调用忘记重新赋值

### 问题描述
GORM的方法调用（如 `Where`、`Limit` 等）都会返回一个新的 `*gorm.DB` 实例，而不是修改原有的实例。

### 错误代码
```go
db := ctx.MustGetOrInitDB()

// ❌ 错误：没有重新赋值，条件不会生效
db.Where("id = ?", 1)
db.Where("status = ?", "正常")
db.Limit(10)

db.Find(&items) // 这里会查询所有数据，忽略上面的条件！
```

### 正确代码
```go
db := ctx.MustGetOrInitDB()

// ✅ 正确：重新赋值，条件生效
db = db.Where("id = ?", 1)
db = db.Where("status = ?", "正常")
db = db.Limit(10)

db.Find(&items) // 这里会应用所有条件
```

### 记忆口诀
**`db = db.Where()` 而不是 `db.Where()`**

## ⚠️ 陷阱2：在条件分支中忘记重新赋值

### 错误代码
```go
if req.IsByFiledValues() {
    db.Where("id in ?", req.GetFiledValues()) // ❌ 没有重新赋值
} else if req.IsByFiledValue() {
    db.Where("id = ?", req.GetFiledValue()).Limit(1) // ❌ 没有重新赋值
} else {
    db.Where("name LIKE ?", "%"+keyword+"%").Limit(20) // ❌ 没有重新赋值
}
db.Find(&items) // 条件不会生效！
```

### 正确代码
```go
if req.IsByFiledValues() {
    db = db.Where("id in ?", req.GetFiledValues()) // ✅ 重新赋值
} else if req.IsByFiledValue() {
    db = db.Where("id = ?", req.GetFiledValue()).Limit(1) // ✅ 重新赋值
} else {
    db = db.Where("name LIKE ?", "%"+keyword+"%").Limit(20) // ✅ 重新赋值
}
db.Find(&items) // 条件生效！
```

## ⚠️ 陷阱3：链式调用中断

### 错误代码
```go
// ❌ 错误：链式调用中断，后面的条件不会生效
db.Where("id = ?", 1)
db.Where("status = ?", "正常") // 这里会覆盖前面的条件
db.Limit(10)
```

### 正确代码
```go
// ✅ 正确：保持链式调用
db = db.Where("id = ?", 1).
    Where("status = ?", "正常").
    Limit(10)
```

## 🎯 最佳实践

1. **始终重新赋值**：`db = db.Where()`
2. **保持链式调用**：避免中断链式调用
3. **条件分支统一**：在条件分支中都要重新赋值
4. **测试验证**：确保条件正确应用

## 🔍 调试技巧

如果怀疑条件没有生效，可以：

1. **打印SQL**：
```go
db = db.Debug().Where("id = ?", 1)
db.Find(&items) // 会打印执行的SQL
```

2. **检查条件**：
```go
ctx.Logger.Infof("查询条件: %+v", db.Statement.Clauses)
```

3. **验证结果**：
```go
var count int64
db.Count(&count)
ctx.Logger.Infof("查询结果数量: %d", count)
```